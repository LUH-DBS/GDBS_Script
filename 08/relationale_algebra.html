
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>8. Relationale Algebra &#8212; Online-Skript Grundlagen der Datenbanksysteme</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. SQL" href="../09/sql.html" />
    <link rel="prev" title="7. Normalisierung" href="../07/normalisierung.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/DBIS_Kurzlogo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Online-Skript Grundlagen der Datenbanksysteme</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Grundlagen der Datenbanksysteme
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../01/einfuehrung.html">
   1. Einführung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../02/historie.html">
   2. Historie
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../03/architektur.html">
   3. Architektur
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/phasenmodell_datenbankentwurf.html">
   4. Phasenmodell für den Datenbankentwurf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../05/er_modellierung.html">
   5. ER-Modellierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../06/relationaler_entwurf.html">
   6. Relationaler Entwurf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../07/normalisierung.html">
   7. Normalisierung
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   8. Relationale Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../09/sql.html">
   9. SQL
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../10/integritaet_und_trigger.html">
   10. Integrität und Trigger
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../11/transaktionen.html">
   11. Transaktionsmanagement
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../12/bearbeitung.html">
   12. Bearbeitung
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/08/relationale_algebra.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/LUH-DBS/GDBS_Script"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F08/relationale_algebra.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/LUH-DBS/GDBS_Script/main/?urlpath=tree/08/relationale_algebra.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#einfuhrung">
   8.1. Einführung
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kriterien-fur-anfragesprachen">
     8.1.1. Kriterien für Anfragesprachen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragealgebra">
     8.1.2. Anfragealgebra
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mengen-vs-multimengen">
     8.1.3. Mengen vs. Multimengen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#basisoperatoren">
   8.2. Basisoperatoren
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#klassifikation-der-operatoren">
     8.2.1. Klassifikation der Operatoren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vereinigung-union-cup">
     8.2.2. Vereinigung (union,
     <span class="math notranslate nohighlight">
      \(\cup\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#differenz-difference">
     8.2.3. Differenz (difference, ―, \)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schnittmenge-intersection-cap">
     8.2.4. Schnittmenge (intersection,
     <span class="math notranslate nohighlight">
      \(\cap\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#projektion-projection-pi">
     8.2.5. Projektion (projection,
     <span class="math notranslate nohighlight">
      \(\pi\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#erweiterte-projektion">
     8.2.6. Erweiterte Projektion
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selektion-selection-sigma">
     8.2.7. Selektion (selection,
     <span class="math notranslate nohighlight">
      \(\sigma\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kartesisches-produkt-cartesian-product-cross-product-times">
     8.2.8. Kartesisches Produkt (Cartesian product, cross product
     <span class="math notranslate nohighlight">
      \(\times\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#der-join-operatorfamilie">
     8.2.9. Der Join – Operatorfamilie
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naturlicher-join-natural-join">
     8.2.10. Natürlicher Join (natural join, ⋈)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#theta-join-theta-join-theta">
     8.2.11. Theta-Join (theta-join,
     <span class="math notranslate nohighlight">
      \(⋈_\theta\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#komplexe-ausdrucke">
     8.2.12. Komplexe Ausdrücke
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umbenennung-rename-rho">
     8.2.13. Umbenennung (rename,
     <span class="math notranslate nohighlight">
      \(\rho\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unabhangigkeit-und-vollstandigkeit">
     8.2.14. Unabhängigkeit und Vollständigkeit
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vorschau-zu-optimierung">
     8.2.15. Vorschau zu Optimierung
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operatoren-auf-multimengen">
   8.3. Operatoren auf Multimengen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#motivation">
     8.3.1. Motivation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#effizienz-durch-multimengen">
     8.3.2. Effizienz durch Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vereinigung-auf-multimengen">
     8.3.3. Vereinigung auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schnittmenge-auf-multimengen">
     8.3.4. Schnittmenge auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#differenz-auf-multimengen">
     8.3.5. Differenz auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#projektion-und-selektion-auf-multimengen">
     8.3.6. Projektion und Selektion auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kreuzprodukt-auf-multimengen">
     8.3.7. Kreuzprodukt auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#joins-auf-multimengen">
     8.3.8. Joins auf Multimengen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#erweiterte-operatoren">
   8.4. Erweiterte Operatoren
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#uberblick-uber-erweiterungen">
     8.4.1. Überblick über Erweiterungen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#duplikateliminierung-duplicate-elimination-delta">
     8.4.2. Duplikateliminierung (duplicate elimination,
     <span class="math notranslate nohighlight">
      \(\delta\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aggregation">
     8.4.3. Aggregation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gruppierung-group-gamma">
     8.4.4. Gruppierung (group,
     <span class="math notranslate nohighlight">
      \(\gamma\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sortierung-sort-tau">
     8.4.5. Sortierung (sort,
     <span class="math notranslate nohighlight">
      \(\tau\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#semi-join">
     8.4.6. Semi-Join (⋊)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#outer-joins-auszere-verbunde">
     8.4.7. Outer Joins (Äußere Verbünde, |⋈|)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#outer-union">
     8.4.8. Outer Union (⊎)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#division-division">
     8.4.9. Division (division, /)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fragen">
   8.5. Fragen
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Relationale Algebra</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#einfuhrung">
   8.1. Einführung
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kriterien-fur-anfragesprachen">
     8.1.1. Kriterien für Anfragesprachen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragealgebra">
     8.1.2. Anfragealgebra
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mengen-vs-multimengen">
     8.1.3. Mengen vs. Multimengen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#basisoperatoren">
   8.2. Basisoperatoren
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#klassifikation-der-operatoren">
     8.2.1. Klassifikation der Operatoren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vereinigung-union-cup">
     8.2.2. Vereinigung (union,
     <span class="math notranslate nohighlight">
      \(\cup\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#differenz-difference">
     8.2.3. Differenz (difference, ―, \)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schnittmenge-intersection-cap">
     8.2.4. Schnittmenge (intersection,
     <span class="math notranslate nohighlight">
      \(\cap\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#projektion-projection-pi">
     8.2.5. Projektion (projection,
     <span class="math notranslate nohighlight">
      \(\pi\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#erweiterte-projektion">
     8.2.6. Erweiterte Projektion
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selektion-selection-sigma">
     8.2.7. Selektion (selection,
     <span class="math notranslate nohighlight">
      \(\sigma\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kartesisches-produkt-cartesian-product-cross-product-times">
     8.2.8. Kartesisches Produkt (Cartesian product, cross product
     <span class="math notranslate nohighlight">
      \(\times\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#der-join-operatorfamilie">
     8.2.9. Der Join – Operatorfamilie
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naturlicher-join-natural-join">
     8.2.10. Natürlicher Join (natural join, ⋈)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#theta-join-theta-join-theta">
     8.2.11. Theta-Join (theta-join,
     <span class="math notranslate nohighlight">
      \(⋈_\theta\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#komplexe-ausdrucke">
     8.2.12. Komplexe Ausdrücke
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umbenennung-rename-rho">
     8.2.13. Umbenennung (rename,
     <span class="math notranslate nohighlight">
      \(\rho\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unabhangigkeit-und-vollstandigkeit">
     8.2.14. Unabhängigkeit und Vollständigkeit
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vorschau-zu-optimierung">
     8.2.15. Vorschau zu Optimierung
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operatoren-auf-multimengen">
   8.3. Operatoren auf Multimengen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#motivation">
     8.3.1. Motivation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#effizienz-durch-multimengen">
     8.3.2. Effizienz durch Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vereinigung-auf-multimengen">
     8.3.3. Vereinigung auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schnittmenge-auf-multimengen">
     8.3.4. Schnittmenge auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#differenz-auf-multimengen">
     8.3.5. Differenz auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#projektion-und-selektion-auf-multimengen">
     8.3.6. Projektion und Selektion auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kreuzprodukt-auf-multimengen">
     8.3.7. Kreuzprodukt auf Multimengen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#joins-auf-multimengen">
     8.3.8. Joins auf Multimengen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#erweiterte-operatoren">
   8.4. Erweiterte Operatoren
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#uberblick-uber-erweiterungen">
     8.4.1. Überblick über Erweiterungen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#duplikateliminierung-duplicate-elimination-delta">
     8.4.2. Duplikateliminierung (duplicate elimination,
     <span class="math notranslate nohighlight">
      \(\delta\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aggregation">
     8.4.3. Aggregation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gruppierung-group-gamma">
     8.4.4. Gruppierung (group,
     <span class="math notranslate nohighlight">
      \(\gamma\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sortierung-sort-tau">
     8.4.5. Sortierung (sort,
     <span class="math notranslate nohighlight">
      \(\tau\)
     </span>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#semi-join">
     8.4.6. Semi-Join (⋊)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#outer-joins-auszere-verbunde">
     8.4.7. Outer Joins (Äußere Verbünde, |⋈|)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#outer-union">
     8.4.8. Outer Union (⊎)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#division-division">
     8.4.9. Division (division, /)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fragen">
   8.5. Fragen
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="relationale-algebra">
<h1><span class="section-number">8. </span>Relationale Algebra<a class="headerlink" href="#relationale-algebra" title="Permalink to this headline">¶</a></h1>
<p>Die Relationale Algebra ist der wohl formalste Teil dieser  Vorlesung. <br>
Zuvor wurde über die Modellierung von Daten gesprochen und wie man relationale Datenbanken entwirft. <br>
Jetzt geht es darum, die zuvor modellierte relationale Datenbank  mit einer Sprache zu manipulieren bzw. neue Sichten darauf zu erstellen und an diese Anfragen zu stellen.</p>
<div class="section" id="einfuhrung">
<h2><span class="section-number">8.1. </span>Einführung<a class="headerlink" href="#einfuhrung" title="Permalink to this headline">¶</a></h2>
<p>In den letzten Kapiteln wurde das Relationsschema mit Basisrelationen, die in der Datenbank gespeichert sind, behandelt. Jetzt geht es um „abgeleitete“ Relationenschemata mit virtuellen Relationen, die aus den Basisrelationen berechnet werden.
<br>
Die „abgeleiteten“ Relationsschemata werden durch Anfragen definiert.
Dafür benötigt man eine Anfragesprache. Anfragen sollen hierbei die Basis-Relationen nicht verändern, sondern neue Relationen generieren, die die erforderten Schemata besitzen.
Das Ergebnis einer Anfrage ist somit immer eine Relation.</p>
<div class="section" id="kriterien-fur-anfragesprachen">
<h3><span class="section-number">8.1.1. </span>Kriterien für Anfragesprachen<a class="headerlink" href="#kriterien-fur-anfragesprachen" title="Permalink to this headline">¶</a></h3>
<p>Für Anfragesprachen gibt es verschiedene Kritieren.</p>
<ul class="simple">
<li><p><strong>Ad-Hoc-Formulierung</strong> Die Nutzenden sollen eine Anfrage formulieren können, ohne ein vollständiges Programm schreiben zu müssen. Wenn man ein neues Programm in einer Sprache wie Python schreibt, muss man Bibliotheken importieren, sich über Effizienz und Datenstrukturen Gedanken machen. Dies soll bei einer Anfragensprache nicht der Fall sein.</p></li>
<li><p><strong>Standardisierung</strong> Eine Anfragesprache sollte einem Standard entsprechend und aus einer minimalen Menge von Vokabularien bestehen. Dennoch besteht der SQL-Standard aus mehr als 1300 Seiten!</p></li>
<li><p><strong>Deklarativität</strong> Ein weiteres Kriterium einer Anfragesprache ist die Deskriptivität bzw. die Deklarativität. Die Nutzenden sollen formulieren was sie haben möchten („Was will ich haben?“) und nicht wie das Ergebnis berechnet werden soll („Wie komme ich an das, was ich haben will?“). Das System erstellt die darunterliegenden Programme automatisch zu der gegebenen Anfrage, ohne dass man die Prozeduren des Programmablaufes beschreiben muss.</p></li>
<li><p><strong>Optimierbarkeit</strong> Zusätzlich muss eine Anfrage optimierbar sein. Eine Sprache besteht aus wenigen Operationen. Für die Operatormenge gibt es Optimierungsregeln. Die Optimierung ist abhängig von der Nutzung bzw. von den Daten. Ein Operator kann entsprechend unterschiedlich teuer im Sinne der des Ressourcenverbrauches sein.</p></li>
<li><p><strong>Effiziente Grundoperatoren</strong> Die Operatoren der Anfragesprache müssen effizient auszuführen sein. Im relationalen Modell hat jede Operation eine Komplexität ≤ <span class="math notranslate nohighlight">\(O(n^2)\)</span>. Wobei <span class="math notranslate nohighlight">\(n\)</span> die Anzahl der Tupel einer Relation darstellt.</p></li>
<li><p><strong>Abgeschlossenheit</strong> Die Abgeschlossenheit ist eine weitere Eigenschaft einer Anfragesprache. Das Ergebnis von Anfragen auf Relationen ist wiederum eine Relation und kann als Eingabe für die nächste Anfrage verwendet werden.</p></li>
<li><p><strong>(Mengenorientiertheit)</strong> Eine weitere, aber nicht sehr strenge, Eigenschaft ist die Mengenorientiertheit. Die Operationen sollen auf Mengen von Daten definiert sein. Dies gilt aber nicht in jedem Fall. Letztendlich möchte man auf Elemente einer Tabelle zugreifen und nicht nur auf einzelne Elemente Datenpunkte, die zusammenhangslos vorkommen.</p></li>
<li><p><strong>Angemessenheit</strong> ist eine weitere Eigenschaft einer Anfragensprache, die beschreibt, ob die Sprache auf das Datenmodell passt. Alle Konstrukte des zugrundeliegenden Datenmodells sollen unterstützt werden. Bei relationalem Datenmodell zählen Relationen, Attribute, Schlüssel, usw.</p></li>
<li><p><strong>Vollständigkeit</strong> Die Vollständigkeit einer Anfragesprache gibt an, dass eine Sprache eine minimale Menge von Operatoren einer Standardsprache abdeckt. In Bezug auf das relationale Modell bedeutet das, dass mindestens die Anfragen einer der relationale Algebra ausgedrückt werden können.</p></li>
<li><p><strong>Sicher</strong> Zuletzt soll eine Anfragesprache „sicher“ sein. Keine Anfrage, die syntaktisch korrekt ist, darf in eine Endlosschleife geraten oder ein unendliches Ergebnis liefern.</p></li>
</ul>
</div>
<div class="section" id="anfragealgebra">
<h3><span class="section-number">8.1.2. </span>Anfragealgebra<a class="headerlink" href="#anfragealgebra" title="Permalink to this headline">¶</a></h3>
<p>In der Mathematik ist die Algebra definiert durch einen Wertebereich und auf diesem definierte Operatoren. <br>
Ein Operand besteht aus Variablen oder aus Werten, aus denen neue Werte konstruiert werden können (x, 2, 3, …).<br>
Ein Operator besteht aus Symbolen, die Prozeduren repräsentieren, die aus gegebenen Werten neue Werte produzieren (+, -, * , /, …).
<br><br>
Für Datenbankanfragen gibt es ebenfalls eine Algebra, die relationale Algebra (RA). Sie ist eine Anfragesprache für das relationale Modell.
Die Inhalte der Datenbank (Relationen) sind die Operanden.
Die Operatoren definieren gewisse Funktionen zum Berechnen von Anfrageergebnissen.
Es sind sehr grundlegenden Dinge, die wir mit Relationen tun wollen.</p>
</div>
<div class="section" id="mengen-vs-multimengen">
<h3><span class="section-number">8.1.3. </span>Mengen vs. Multimengen<a class="headerlink" href="#mengen-vs-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Bei der relationalen Algebra geht es hauptsächlich um Mengen. Bei normalen Mengen darf kein Tupel doppelt auftauchen. Bei Multimengen können identische Tupel mehrmals vorkommen. Es kann nämlich in einer Datenbanktabelle passieren, dass die Schlüssel nicht ordentlich definiert sind. Dann hat man sozusagen ein „Sack voll mit Tupeln“ (engl. „bag“).<br />
<br>
Die Operatoren der relationalen Algebra sind auf Mengen definiert, wohingegen die Operatoren auf einem DBMS (SQL-Anfragen) auf Multimengen definiert sind. Dies hat verschiedene Gründe. Zum Einem wird hiermit die Effizienz beeinflusst bzw. gesteigert. Dazu kann man sich überlegen wie man eine Vereinigung als Multimenge und eine Vereinigung als Menge implementiert.</p>
</div>
</div>
<div class="section" id="basisoperatoren">
<h2><span class="section-number">8.2. </span>Basisoperatoren<a class="headerlink" href="#basisoperatoren" title="Permalink to this headline">¶</a></h2>
<p>Die Basisoperatoren der Relationalen Algebra werden in verschiedene Klassen eingeteilt. In diesem Unterkapitel wird zudem auf verschiedene Operatoren noch genauer eingegangen.</p>
<div class="section" id="klassifikation-der-operatoren">
<h3><span class="section-number">8.2.1. </span>Klassifikation der Operatoren<a class="headerlink" href="#klassifikation-der-operatoren" title="Permalink to this headline">¶</a></h3>
<p>Die bereits bekannten Mengenoperatoren sind die Vereinigung, Schnittmenge und die Differenz. Hinzu kommen entfernende Operatoren. Diese werden auf einzelne Elemente angewandt. Dazu zählen Selektionen und Projektionen.<br>
Mit kombinierenden Operatoren kann man mehrere Relationen miteinander verbinden und neue Kombinationen von Tupeln bilden. Im Gegensatz zu den Mengenoperationen bei denen die Ergebnistupel immer gleich aussehen, kann es bei den kombinierenden Operatoren dazu kommen, dass die Ergebnistupel in ihren Attributen unterschiedlich aussehen. Typische Operatoren dafür sind das Kartesische Produkt, ein Join bzw. die verschiedenen Joinvarianten. <br>
Die Umbenennung ist die einzige Ooeration, die nicht die Tupel verändert, sondern das Schema. <br>
Ein Ausdruck in der Relationlen Algebra besteht aus einer Kombination von Operatoren und Operanden, auch Anfragen (queries) genannt.</p>
</div>
<div class="section" id="vereinigung-union-cup">
<h3><span class="section-number">8.2.2. </span>Vereinigung (union, <span class="math notranslate nohighlight">\(\cup\)</span>)<a class="headerlink" href="#vereinigung-union-cup" title="Permalink to this headline">¶</a></h3>
<p>Die Vereinigung sammelt Elemente (Tupel) zweier Relationen unter einem gemeinsamen Schema auf.</p>
<ul class="simple">
<li><p>R ∪ S := {t | t <span class="math notranslate nohighlight">\(\in\)</span> R <span class="math notranslate nohighlight">\(\vee\)</span> t <span class="math notranslate nohighlight">\(\in\)</span> S}</p></li>
</ul>
<p>Um eine Vereinigung anwenden zu können, müssen die Attributmengen beider Relationen identisch sein. Dazu gehören die Namen, Typen und die Reihenfolge. Wenn man beispielsweise die Attribute  in einer Tabelle in einem anderen Format hat als in der Anderen und die Werte vom gleichen Typ sind, kann mam diese Umbenennen und dennoch eine Vereinigung bilden.
<br>
Ein Element ist nur einmal in der Vereinigung von R und S (R ∪ S) vertreten, auch wenn es jeweils einmal in R und S auftaucht. Es kommt zu einer Duplikatentfernung.</p>
<p>Das Beispiel zeigt zwei Tabellen R und S mit jeweils Name, Adresse, Geschlecht und Geburt.
Wenn man diese Relationen miteinander vereinigt, erhält man eine neue Relation, in der das Tupel mit “Carrie Fisher” nur ein Mal vorkommt.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Name</strong></p></td>
<td><p><strong>Adresse</strong></p></td>
<td><p><strong>Geschlecht</strong></p></td>
<td><p><strong>Geburt</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
<tr class="row-even"><td><p>Mark Hamill</p></td>
<td><p>456 Oak. Rd., Brentwood</p></td>
<td><p>M</p></td>
<td><p>8/8/88</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Name</strong></p></td>
<td><p><strong>Adresse</strong></p></td>
<td><p><strong>Geschlecht</strong></p></td>
<td><p><strong>Geburt</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
<tr class="row-even"><td><p>Harrison Ford</p></td>
<td><p>789 Palm Dr., Beverly Hills</p></td>
<td><p>M</p></td>
<td><p>7/7/77</p></td>
</tr>
</tbody>
</table>
</table><p><span class="math notranslate nohighlight">\(R \cup S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Adresse</p></th>
<th class="head"><p>Geschlecht</p></th>
<th class="head"><p>Geburt</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
<tr class="row-odd"><td><p>Mark Hamill</p></td>
<td><p>456 Oak. Rd., Brentwood</p></td>
<td><p>M</p></td>
<td><p>8/8/88</p></td>
</tr>
<tr class="row-even"><td><p>Harrison Ford</p></td>
<td><p>789 Palm Dr., Beverly Hills</p></td>
<td><p>M</p></td>
<td><p>7/7/77</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="differenz-difference">
<h3><span class="section-number">8.2.3. </span>Differenz (difference, ―, \)<a class="headerlink" href="#differenz-difference" title="Permalink to this headline">¶</a></h3>
<p>Die Differenz in der Relationalen Algebra ist sehr ähnlich zu der aus der Mathematik. <br>
Die Differenz von R und S (R − S) eliminiert die Tupel aus der ersten Relation, die auch in der zweiten Relation vorkommen. Die Schemata beider Relationen müssen für eine Differenz gleich sein.
<br></p>
<ul class="simple">
<li><p>R − S := {t | t <span class="math notranslate nohighlight">\(\in\)</span> R <span class="math notranslate nohighlight">\(\wedge\)</span> t <span class="math notranslate nohighlight">\(\notin\)</span> S}</p></li>
</ul>
<p>Die Kommutativität gilt bei der Differenz nicht:</p>
<ul class="simple">
<li><p>R − S ≠ S − R</p></li>
</ul>
<p>In dem folgendem Beispiel gibt es sowohl in der Relation R, als auch in der Relation S, das gleiche Tupel mit “Carrie Fisher”. Bei der Differenz (R-S) wird das in beiden vorkommende Tupel eliminiert.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Name</strong></p></td>
<td><p><strong>Adresse</strong></p></td>
<td><p><strong>Geschlecht</strong></p></td>
<td><p><strong>Geburt</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
<tr class="row-even"><td><p>Mark Hamill</p></td>
<td><p>456 Oak. Rd., Brentwood</p></td>
<td><p>M</p></td>
<td><p>8/8/88</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Name</strong></p></td>
<td><p><strong>Adresse</strong></p></td>
<td><p><strong>Geschlecht</strong></p></td>
<td><p><strong>Geburt</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
<tr class="row-even"><td><p>Harrison Ford</p></td>
<td><p>789 Palm Dr., Beverly Hills</p></td>
<td><p>M</p></td>
<td><p>7/7/77</p></td>
</tr>
</tbody>
</table>
</table>
<p><span class="math notranslate nohighlight">\(R-S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Adresse</p></th>
<th class="head"><p>Geschlecht</p></th>
<th class="head"><p>Geburt</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Mark Hamill</p></td>
<td><p>456 Oak. Rd., Brentwood</p></td>
<td><p>M</p></td>
<td><p>8/8/88</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="schnittmenge-intersection-cap">
<h3><span class="section-number">8.2.4. </span>Schnittmenge (intersection, <span class="math notranslate nohighlight">\(\cap\)</span>)<a class="headerlink" href="#schnittmenge-intersection-cap" title="Permalink to this headline">¶</a></h3>
<p>Die Schnittmenge R <span class="math notranslate nohighlight">\(\cap\)</span> S ergibt die Tupel, die in beiden Relationen gemeinsam vorkommen.<br></p>
<ul class="simple">
<li><p>R <span class="math notranslate nohighlight">\(\cap\)</span> S := {t | t <span class="math notranslate nohighlight">\(\in\)</span> R <span class="math notranslate nohighlight">\(\wedge\)</span> t <span class="math notranslate nohighlight">\(\in\)</span> S}</p></li>
</ul>
<p>Die Schnittmenge als Operator kann durch Verinigungen und Differenzen dargestellt werden, daher ist sie prinzipiell „überflüssig“.</p>
<ul class="simple">
<li><p>R <span class="math notranslate nohighlight">\(\cap\)</span> S = R − (R − S) = S − (S − R)</p></li>
</ul>
<p><img alt="title" src="../_images/schnittmenge.jpg" /></p>
<p>Das Beispiel dazu zeigt zwei Relationen R und S. In Relation R, sowie in Relation S, gibt es ein identisches “Carrie Fisher” Tupel. Bildet man die Schnittmenge der beiden Relationen (<span class="math notranslate nohighlight">\(R\cap S\)</span>), sind in der Ergebnisrelation alle Tupel, die sowohl in R, als auch in S vorkommen. In diesem Fall wäre es nur das Tupel mit “Carrie Fisher”.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Name</strong></p></td>
<td><p><strong>Adresse</strong></p></td>
<td><p><strong>Geschlecht</strong></p></td>
<td><p><strong>Geburt</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
<tr class="row-even"><td><p>Mark Hamill</p></td>
<td><p>456 Oak. Rd., Brentwood</p></td>
<td><p>M</p></td>
<td><p>8/8/88</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Name</strong></p></td>
<td><p><strong>Adresse</strong></p></td>
<td><p><strong>Geschlecht</strong></p></td>
<td><p><strong>Geburt</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
<tr class="row-even"><td><p>Harrison Ford</p></td>
<td><p>789 Palm Dr., Beverly Hills</p></td>
<td><p>M</p></td>
<td><p>7/7/77</p></td>
</tr>
</tbody>
</table>
</table>
<p><span class="math notranslate nohighlight">\(R\cap S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Adresse</p></th>
<th class="head"><p>Geschlecht</p></th>
<th class="head"><p>Geburt</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Carrie Fisher</p></td>
<td><p>123 Maple St., Hollywood</p></td>
<td><p>F</p></td>
<td><p>9/9/99</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="projektion-projection-pi">
<h3><span class="section-number">8.2.5. </span>Projektion (projection, <span class="math notranslate nohighlight">\(\pi\)</span>)<a class="headerlink" href="#projektion-projection-pi" title="Permalink to this headline">¶</a></h3>
<p>Die Projektion ist ein unärer Operator. Sie erzeugt eine neue Relation mit einer Teilmenge der ursprünglichen Attribute.<br>
Angenommen man projiziert auf eine Relation R mit den Attributen A1 bis Ak: <span class="math notranslate nohighlight">\(\pi_{A1,A2,…,Ak}\)</span>( R ). Als Ergbnis erhält man eine neue Relation mit einer Teilmenge der ursprünglichen Attribute von R. Die Reihenfolge der Attribute entspricht üblicherweise der aufgelisteten Reihenfolge.<br><br>
Durch das Weglassen von Attributen, kann es dazu kommen, dass die übrig gebliebenen Attribute  Duplikate enthalten. Diese werden implizit entfernt. <br>
Ein Beispiel hierzu: Man bildet eine Projektion mit den Attributen A und B auf R. Das Ergebnis sind zwei identische Tupel. Das Duplikat wird eliminiert.</p>
<p>Relation R</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>3</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\pi_{A,B}\)</span>( R )</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>Hier sind zwei weitere Beispiele zu Projektionen anhand einer Film-Tabelle dargestellt. <br>
Im ersten Beispiel werden bei der Projektion nur die Spalten Titel, Jahr und Länge behalten. Die anderen Spalten werden weggeschnitten. <br>
In zweitem Beispiel kommt ‘True’ doppelt vor und daher werden dessen Duplikate entfernt.</p>
<p>Film</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>inFarbe</p></th>
<th class="head"><p>Studio</p></th>
<th class="head"><p>ProduzentID</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>True</p></td>
<td><p>Fox</p></td>
<td><p>12345</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
<td><p>True</p></td>
<td><p>Disney</p></td>
<td><p>67890</p></td>
</tr>
<tr class="row-even"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>121</p></td>
<td><p>False</p></td>
<td><p>Paramount</p></td>
<td><p>99999</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\pi_{Titel,Jahr,Länge}\)</span>(Film)</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
</tr>
<tr class="row-even"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>121</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\pi_{inFarbe}\)</span>(Film)</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>inFarbe</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>True</p></td>
</tr>
<tr class="row-odd"><td><p>False</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="erweiterte-projektion">
<h3><span class="section-number">8.2.6. </span>Erweiterte Projektion<a class="headerlink" href="#erweiterte-projektion" title="Permalink to this headline">¶</a></h3>
<p>Die Relationale Algebra erlaubt es den Projektionsoperator mehr Fähigkeiten zu geben. Bei der einfachen Projektion zuvor (<span class="math notranslate nohighlight">\(\pi_{L}\)</span>( R )) war das L dabei ‘nur’ eine Attributliste. Die erweiterte Projektion kann neben der Attributliste auch andere Ausdrücke an der Stelle des L’s stehen haben. <br>
Ein anderer Ausdruck wäre A→B, wobei A ein Attribut in R und B ein neuer Name ist. Dies entspricht einer Umbenennung von Attributen. <br>
Eine weitere Möglichkeit für einen neuen Ausdruck ist e→C. e ist ein Ausdruck mit Konstanten, arithmetischen Operatoren, Attributen von R, String-Operationen. C ist der neue Name für den Ausdruck e. Zwei Beispiele hierfür:</p>
<ul class="simple">
<li><p>A1 + A2 → Summe</p></li>
<li><p>Vorname || ` ` || Nachname → Name</p></li>
</ul>
</div>
<div class="section" id="selektion-selection-sigma">
<h3><span class="section-number">8.2.7. </span>Selektion (selection, <span class="math notranslate nohighlight">\(\sigma\)</span>)<a class="headerlink" href="#selektion-selection-sigma" title="Permalink to this headline">¶</a></h3>
<p>Ein weiterer unärer Operator ist die Selektion. Sie erzeugt eine neue Relation mit gleichem Schema, aber einer Teilmenge der Tupel. Einfach ausgedrückt kann man sagen, dass eine Selektion die Anzahl der Tupel reduziert.  <br>
Nur Tupel, die der Selektionsbedingung C (condition) entsprechen, werden in die neu erzeugte Relation übernommen. Für jedes Tupel wird somit einmal die Bedingung geprüft. Es handelt sich bei den Selektionsbedingungen um boolesche Selektionsbedingungen wie man sie aus Programmiersprachen kennt. <br>
Die Operanden der Selektionsbedingung sind nur Konstanten oder Attribute von R. Diese können mittels Vergleichsoperatoren wie &lt;, &gt;, ≤, <span class="math notranslate nohighlight">\(\ge\)</span>, &lt;&gt; und = verglichen werden. const = const ist ein Beispiel dafür wie so etwas aussehen kann. Ist aber eigentlich unnötig, da es sich um Konstanten handelt. Eine typische Selektion ist ein Vergleich zwischen Attribut und Konstante (attr = const). Wenn man zwei Attribute miteinander vergleicht, (attr = attr) kann man mögliche Attribute finden, an denen die zwei Relationen gejoint werden können. Das würde einer Join Bedingung entsprechen. <br>
Die einzelnen Selektionsbedingungen können zu einer gesamten Selektionsbedingung durch AND, OR und NOT kombiniert werden.<br>
<br>
Nicht zu verwechseln sind die Selektion aus der Relationalen Algebra mit dem SELECT aus SQL. Das SELECT entspricht in der Relationalen Algebra einer Projektion. Die Selektion wiederrum entspricht in SQL einer WHERE-Bedingung:</p>
<ul class="simple">
<li><p>Selektion <span class="math notranslate nohighlight">\(\neq\)</span> SELECT</p></li>
</ul>
<p>Die Beispiele zeigen verschiedene Selektionen auf einer gegebenen Film-Relation. <br>
Im ersten Beispiel werden alle Filme selektiert, dessen Länge größer oder gleich 100 Minuten ist. <br>
Im zweitem Beispiel kommt noch hinzu, dass diese Filem vom Fox-Studio produziert worden sein müssen.</p>
<p>Film</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>inFarbe</p></th>
<th class="head"><p>Studio</p></th>
<th class="head"><p>ProduzentID</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>True</p></td>
<td><p>Fox</p></td>
<td><p>12345</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
<td><p>True</p></td>
<td><p>Disney</p></td>
<td><p>67890</p></td>
</tr>
<tr class="row-even"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>90</p></td>
<td><p>False</p></td>
<td><p>Paramount</p></td>
<td><p>99999</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\sigma_{Länge\geq100}\)</span>(Film)</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>inFarbe</p></th>
<th class="head"><p>Studio</p></th>
<th class="head"><p>ProduzentID</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>True</p></td>
<td><p>Fox</p></td>
<td><p>12345</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
<td><p>True</p></td>
<td><p>Disney</p></td>
<td><p>67890</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\sigma_{Länge\geq100 AND Studio='Fox'}\)</span>(Film)</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>inFarbe</p></th>
<th class="head"><p>Studio</p></th>
<th class="head"><p>ProduzentID</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>True</p></td>
<td><p>Fox</p></td>
<td><p>12345</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="kartesisches-produkt-cartesian-product-cross-product-times">
<h3><span class="section-number">8.2.8. </span>Kartesisches Produkt (Cartesian product, cross product <span class="math notranslate nohighlight">\(\times\)</span>)<a class="headerlink" href="#kartesisches-produkt-cartesian-product-cross-product-times" title="Permalink to this headline">¶</a></h3>
<p>Das Kartesische Produkt ist ein binärer Operator. Benannt worden ist es nach René Descartes. Ein französischer Naturwissenschaftler, Mathematiker und Philosoph. Das Kartesische Produkt ist auch unter anderen Namen wie Kreuzprodukt oder Produkt bekannt. Außerdem gibt es verschiedene Schreibweisen dafür: R * S statt R <span class="math notranslate nohighlight">\(\times\)</span> S
<br><br>
Das Kreuzprodukt zweier Relationen R und S ist die Menge aller Tupel, die man erhält, wenn man jedes Tupel aus R mit jedem Tupel aus S kombiniert. Das Schema hat ein Attribut für jedes Attribut aus R und S. Bei Namensgleichheit von zwei oder mehreren Attributen wird kein Attribut ausgelassen, stattdessen werden sie eindeutig umbenannt.</p>
<p><img alt="title" src="../_images/descartes.jpg" /></p>
<p>Das Beispiel zum Kartesischen Produkt zeigt zwei Relationen R und S, die mittels Kreuzprodukt kombiniert werden. Dazu werden alle möglichen Kombinationen der Tupel gebildet. Die Relationen R und S haben ein Attribut mit dem selben Namen (B). In der neuen Ergbnisrelation wird das Attribut jeweils eindeutig umbenannt. Bei der Umbennenung wird als Präfix der Relationsname vor das Attribut geschrieben: R.B und S.B.</p>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p><br><br></p>
<p><span class="math notranslate nohighlight">\(S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(R \times S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>R.B</p></th>
<th class="head"><p>S.B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="der-join-operatorfamilie">
<h3><span class="section-number">8.2.9. </span>Der Join – Operatorfamilie<a class="headerlink" href="#der-join-operatorfamilie" title="Permalink to this headline">¶</a></h3>
<p>Die folgenden Joins bilden eine Übersicht über die Joins, die in dieser Veranstaltung genauer betrachtet werden:</p>
<ul class="simple">
<li><p>Natürlicher Join (natural join)</p></li>
<li><p>Theta-Join</p></li>
<li><p>Equi-Join</p></li>
<li><p>Semi-Join und Anti-Join</p></li>
<li><p>Left-outer Join und Right-outer Join</p></li>
<li><p>Full-outer Join</p></li>
</ul>
</div>
<div class="section" id="naturlicher-join-natural-join">
<h3><span class="section-number">8.2.10. </span>Natürlicher Join (natural join, ⋈)<a class="headerlink" href="#naturlicher-join-natural-join" title="Permalink to this headline">¶</a></h3>
<p>Der natürliche Join ist ein binärer Operator.
Beim Kreuzprodukt zuvor wurden alle möglichen Tupelpaare gebildet. Im Gegensatz dazu werden beim natürlichen Join Tupelpaare gebildet aus Tupeln, die „irgendwie“ übereinstimmen.
Es werden Tupel miteinander verbunden, die eine Übereinstimmung in allen gemeinsamen Attributen besitzen.
Somit handelt es sich dabei um einen „Verbund“ von Tupeln miteinander. Gegebenenfalls ist beim „Verbinden“ eine Umbennung der Attribute erforderlich. Zum Beispiel wäre dies erforderlich bei zwei Attributen in unterschiedlichen Relationen, wenn die Attribute das Selbe aussagen, aber unterschiedlich benannt worden sind.
<br><br>
Der natürliche Join arbeitet nach dem Schema: Vereinigung der beiden Attributmengen. Im Vergleich zum Kreuzprodukt gibt es nicht mehr die gleichen Attribute doppelt und umbenannt. Das Ergebnis ist nun eine Menge aus Attributen, also ohne (umbenannte) Duplikate. <br>
Die Grafik zeigt passend dazu den natürlichen Join zwischen zwei Relationen. Die Rechtecke stellen Attribute und der Verbund von Rechtecken Relationen dar. Beide ursprünglichen Relationen bestehen aus zwei Attributen, wobei das orangene Attribut in beiden gleich ist. Die erste Relation (oben) besteht zusätzlich noch aus einem blauen und die zweite Relation (unten) aus einem grünen Attribut. Bei einem natürlichen Join beider Relationen wird über die identischen Attribute beider Relationen gejoint. In diesem Fall ist es das orangefarbene Attribut. Die Ergebnisrelation enthält somit am Ende das blaue, grüne und nur einmal das orangene Attribut.</p>
<p><img alt="title" src="../_images/njoin.jpg" /></p>
<p>Beim natürlichen Join gibt es verschiedene Notationen. <br>
r[A] beschreibt eine Projektion des Tupels r auf dem Attribut A. Es gibt somit genau den Wert des Tupels R beim Attribut A an. <br>
Gegeben sind nun zwei Relationen R und S. Beide Relationen haben die gemeinsamen Attribute A1, …, Ak. Dann wird der natürliche Join wie folgt definiert:</p>
<ul class="simple">
<li><p>R ⋈ S = {r <span class="math notranslate nohighlight">\(\cup\)</span> s | r<span class="math notranslate nohighlight">\(\in\)</span>R <span class="math notranslate nohighlight">\(\wedge\)</span> s<span class="math notranslate nohighlight">\(\in\)</span>S <span class="math notranslate nohighlight">\(\wedge\)</span> r[A1]=s[A1] <span class="math notranslate nohighlight">\(\wedge\)</span> … <span class="math notranslate nohighlight">\(\wedge\)</span> r[Ak]=s[Ak] }<br>
Achtung: Bei der Verinigung von r und s handelt es sich also um Tupelwerte und nicht um Relationen!<br></p></li>
</ul>
<p>Eine alternative, üblichere Definition ist eine Selektion auf dem Kreuzprodukt der Relationen R und S. Die Selektion hat dabei als Bedingung, dass die Werte gleicher Spalten, übereinstimmen.
Dabei muss noch projiziert und umbenannt werden, um die Vereinigung richtig zu erwirken.</p>
<ul class="simple">
<li><p>R ⋈ S = s r[A1]=s[A1] <span class="math notranslate nohighlight">\(\wedge\)</span> … <span class="math notranslate nohighlight">\(\wedge\)</span> r[Ak]=s[Ak](R × S)</p></li>
</ul>
<p>Dazu ein Beispiel: Die ursprünglichen Tabellen sind R und S. Auf diesen beiden wird ein natürlicher Join ausgeführt. Dabei wird nur auf gleichen Attributen gejoint. In diesem Fall ist es das Attribut B. R und S stimmen in B in den Werten 2 und 4 überein. Das übrig gebliebene Tupel mit der 9 in B, muss somit nicht mehr kombiniert werden.</p>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(R ⋈ S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
<p>Zur Erinnerung ist hier das kartesische Produkt der Relationen R und S dargestellt. Hierauf könnte man die alternative bzw. üblichere Definition des natürlichen Joins anwenden. Man würde wieder die gleichen zwei Tupel nach der Selektion erhalten. Zusätzlich müsste man noch R.B oder S.B wegprojizieren.</p>
<p><span class="math notranslate nohighlight">\(R \times S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>R.B</p></th>
<th class="head"><p>S.B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
<p>Bei dem zweiten Beispiel gibt es mehr als ein gemeinsames Attribut. Es stimmen in R und S die zwei Attribute B und C überein. B und C müssen somit gleichzeitig bei jedem Join übereinstimmen. <br>Obwohl der Wert von B (2) im ersten Tupel beider Relationen übereinstimmt, können diese nicht gejoint werden. Der Grund dafür sind unterschiedliche Werte (3 != 5) im Attribut C. <br>
Das erste Tupel aus R und das zweite Tupel aus S haben wiederum in B und C die gleichen Werte und können somit gejoint werden. Genauso haben das zweite und dritte Tupel von R die gleichen Werte in B und C wie das dritte Tupel von S. Das dritte Tupel in S wird also mit mehr als einem Partner verknüpft.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
<td><p><strong>C</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>B</strong></p></td>
<td><p><strong>C</strong></p></td>
<td><p><strong>D</strong></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>3</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</table>
<p><span class="math notranslate nohighlight">\(R ⋈ S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="theta-join-theta-join-theta">
<h3><span class="section-number">8.2.11. </span>Theta-Join (theta-join, <span class="math notranslate nohighlight">\(⋈_\theta\)</span>)<a class="headerlink" href="#theta-join-theta-join-theta" title="Permalink to this headline">¶</a></h3>
<p>Der Theta Join ist die Allgemeinste Form der Joins. Der natürliche Join ist also ein Spezialfall vom Theta-Join.
Die Verknüpfungsbedingung kann selbst gestaltet werden. Zuvor war die Bedingung, dass die Attribute auf denen gejoint wird, gleich sind.<br>
Das Ergebnis wird ähnlich wie zuvor konstruiert. Zunächst wird ein Kreuzprodukt der beiden Relationen gebildet. Selektiert wird darauf mittels der gegebenen Joinbedingung <span class="math notranslate nohighlight">\(\theta\)</span>. Dabei ist A ein Attribut in R und B ein Attribut in S.</p>
<ul class="simple">
<li><p>R ⋈<span class="math notranslate nohighlight">\(A_\theta\)</span> B S = s <span class="math notranslate nohighlight">\(A_\theta\)</span> B (R <span class="math notranslate nohighlight">\(\times\)</span> S)</p></li>
<li><p><span class="math notranslate nohighlight">\(\theta\)</span> ∈ {=, &lt;, &gt;, ≤, ≥, ≠}</p></li>
</ul>
<p>Das Schema der Ergebnisrelation eines Theta-Joins sieht wie das Schema vom Kreuzprodukt aus. Wenn die Joinbedingung der Operator „=“ ist, handelt es sich um einen Equi-Join. Dieser ist somit, wie auch der Natural-Join, ein Spezialfall des Theta-Joins. Der Unterschied zum Natural Join ist aber, dass das Schema des Ergebnisses anders aussieht als beim Equi-Join. Gleiche Attribute werden umbenannt und sozusagen zu einem Attribut zusammengefasst.</p>
<ul class="simple">
<li><p>R(A,B,C) ⋈ S(B,C,D) <br>
= <span class="math notranslate nohighlight">\(\rho_{T(A,B,C,D)}\)</span>(<span class="math notranslate nohighlight">\(\pi_{A,R.B,R.C,D}\)</span>(<span class="math notranslate nohighlight">\(\sigma_{(R.B=S.B AND R.C = S.C)}\)</span> (<span class="math notranslate nohighlight">\(R \times S\)</span>)))</p></li>
</ul>
<p>Im ersten Beispiel zum Theta-Join werden R und S gejoint, wenn der Wert vom Attribut A kleiner als der von D ist. Zunächst wird das erste Tupel von R mit allen Tupeln von S verglichen. In jedem Fall stimmt die Bedingung und die Tupel können verbunden werden. Analog werden die weiteren Tupel von R mit denen von S verglichen und gegebenenfalls verbunden.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
<td><p><strong>C</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>B</strong></p></td>
<td><p><strong>C</strong></p></td>
<td><p><strong>D</strong></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>3</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</table><p><span class="math notranslate nohighlight">\(R ⋈_{A&lt;D}S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>R.B</p></th>
<th class="head"><p>R.C</p></th>
<th class="head"><p>S.B</p></th>
<th class="head"><p>S.C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
<p>Im zweitem Beispiel wird die Bedingung erweitert. R.B und S.B dürfen nicht mehr gleich sein. Wie zuvor wird jede Zeile von R mit jeder Zeile von S verglichen und geprüft, ob die Bedingung stimmt. Falls ja, werden die Tupel miteinander verknüpft. Generell können Bedingungen beliebig lang werden.</p>
<p><span class="math notranslate nohighlight">\(R ⋈_{A&lt;D \wedge R.B \neq S.B}S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>R.B</p></th>
<th class="head"><p>R.C</p></th>
<th class="head"><p>S.B</p></th>
<th class="head"><p>S.C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="komplexe-ausdrucke">
<h3><span class="section-number">8.2.12. </span>Komplexe Ausdrücke<a class="headerlink" href="#komplexe-ausdrucke" title="Permalink to this headline">¶</a></h3>
<p>Die Idee hinter komplexen Ausdrücken ist die Kombination (Schachtelung) von Ausdrücken zur Formulierung komplexer Anfragen. <br>
Aufgrund der Abgeschlossenheit der relationalen Algebra kann der Output eines Ausdrucks, der immer eine Relation ist, als Input für den nächsten Ausdruck verwendet werden. <br>
Die Darstellung von komplexen Ausdrücken erfolgt mittels Klammerung und Schachtelung von Ausdrücken. Die komplexen Ausdrücke können in einen Baum aufgespalten und dargestellt werden.</p>
<p>Film</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>Typ</p></th>
<th class="head"><p>StudioName</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>Farbe</p></td>
<td><p>Fox</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
<td><p>Farbe</p></td>
<td><p>Disney</p></td>
</tr>
<tr class="row-even"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>90</p></td>
<td><p>s/w</p></td>
<td><p>Paramount</p></td>
</tr>
</tbody>
</table>
<p>Als Beispiel zu komplexen Ausdrücken sei hier eine Film-Relation gegeben. Gesucht werden Titel und Jahr von den Filmen, die von Fox produziert wurden. Die Filme sollen mindestens 100 Minuten lang sein. <br>
Um die Beispielanfrage in die Relationale Algebra zu übersetzen, wird die Anfrage Stück für Stück durchgegangen und umgewandelt. In diesem Beispiel fangen wir von innen heraus an. <br>
Gesucht werden Filme, die von Fox produziert worden sind. Somit wird eine Selektion mit der Selektionsbedingung StudioName=‘Fox’ auf der Film-Relation benötigt (<span class="math notranslate nohighlight">\(\sigma_{StudioName=‚Fox‘}\)</span>(Film)).
Die zweite Bedingung fordert, dass alle Filme mindestens 100 Minuten lang sind. Dafür wird wieder eine Selektion auf der Film-Relation angewandt <span class="math notranslate nohighlight">\(\sigma_{Länge≥100}\)</span>(Film).
Da beide Bedingungen gleichzeitig gelten sollen, nimmt man die Schnittmenge von den beiden zuvor verwendeten Selektionen (<span class="math notranslate nohighlight">\(\sigma_{Länge≥100}\)</span>(Film) <span class="math notranslate nohighlight">\(\cap\)</span> <span class="math notranslate nohighlight">\(\sigma_{StudioName=‚Fox‘}\)</span>(Film)).
Alternativ lässt sich als eine längere Selektionsbedingung darstellen. Dazu werden beide Bedingungen mit einem AND verknüpft (<span class="math notranslate nohighlight">\(\sigma_{Länge≥100 AND StudioName=‚Fox‘}\)</span>(Film)).
Da nach Titeln und Jahr gesucht wird, wird die Relation am Ende auf die Attribute Titel und Jahr noch projiziert (<span class="math notranslate nohighlight">\(\pi_{Titel,Jahr}\)</span>(…)). <br>
Die vollständige Anfrage in Relationaler Algebra sieht wie folgt aus:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\pi_{Titel,Jahr}\)</span>(<span class="math notranslate nohighlight">\(\sigma_{Länge≥100}\)</span>(Film) <span class="math notranslate nohighlight">\(\cap\)</span> <span class="math notranslate nohighlight">\(\sigma_{StudioName=‚Fox‘}\)</span>(Film))
oder in alternativer Form:</p></li>
<li><p><span class="math notranslate nohighlight">\(\pi_{Titel,Jahr}\)</span>(<span class="math notranslate nohighlight">\(\sigma_{Länge≥100 AND StudioName=‚Fox‘}\)</span>(Film))</p></li>
</ul>
<p>Generell gibt es aber viele verschiedene Möglichkeiten wie ein solcher Ausdruck formuliert wird.</p>
<p>Das folgende Beispiel zeigt wie ein Baum von innen heraus aufgespannt wird. Dabei wird mit der Film Relation und den Selektionen darauf begonnen. Danach werden die Ergebnisrelationen beider Selektionen durch eine Schnittmenge verbunden. Zuletzt wird durch die Projektion die Spalten Titel und Jahr ausgegeben.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{Titel,Jahr}\)</span>(<span class="math notranslate nohighlight">\(\sigma_{Länge≥100(Film)}\)</span> <span class="math notranslate nohighlight">\(\cap\)</span> <span class="math notranslate nohighlight">\(\sigma_{StudioName=‚Fox‘}\)</span>(Film))</p></li>
</ul>
<p><img alt="title" src="../_images/komplex_bsp1.jpg" /></p>
<p>Zu der Alternative sähe der Baum dementsprechend anders aus. Er würde nur aus einer Film Relation, einer Selektion mit längerer Selektionsbedingung und einer Projektion bestehen. Letztendlich kommt bei beiden Ausdrücken die selbe Relation heraus.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{Titel,Jahr}\)</span>(<span class="math notranslate nohighlight">\(\sigma_{Länge≥100 AND StudioName=‚Fox‘}\)</span>(Film))</p></li>
</ul>
<p>Gegeben sind in diesem Beispiel zwei Relationen: Film und Rolle. Gesucht werden die Namen aller Schauspieler, die in den Filmen mitspielten, die mindestens 100 Minuten lang sind. <br>
Die Schauspielernamen sind in einer anderen Tabelle als die Filme. Die Tabellen müssen irgendwie verlinkt werden. Dazu eignet sich die beiden Relationen (mittels einem natürlichen Join) zu joinen (Film ⋈ Rolle). Aus dieser Ergebnisrelation werden alle Filme selektiert, die mindestens 100 Minuten lang sind (<span class="math notranslate nohighlight">\(\sigma_{Länge≥100}\)</span>(…)). Da nur nach den Schauspielernamen gesucht wird, wird auf den Schauspielernamen projiziert (<span class="math notranslate nohighlight">\(\rho_{SchauspName}\)</span>(…)).</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{SchauspName}\)</span>(<span class="math notranslate nohighlight">\(\sigma_{Länge≥100}\)</span>(Film ⋈ Rolle))</p></li>
</ul>
<p>Film</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>Typ</p></th>
<th class="head"><p>StudioName</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>Farbe</p></td>
<td><p>Fox</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
<td><p>Farbe</p></td>
<td><p>Disney</p></td>
</tr>
<tr class="row-even"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>90</p></td>
<td><p>s/w</p></td>
<td><p>Paramount</p></td>
</tr>
</tbody>
</table>
<p>Rolle</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>SchauspName</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>Sharon Stone</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>Sharon Stone</p></td>
</tr>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>Arnold</p></td>
</tr>
<tr class="row-odd"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>Johnny Depp</p></td>
</tr>
</tbody>
</table>
<p>Zum Verständnis noch ein weiteres Beispiel:</p>
<ul class="simple">
<li><p>Stud(Matrikel, Name, Semester)</p></li>
<li><p>Prof(ProfName, Fachgebiet, GebJahr)</p></li>
<li><p>VL(VL_ID, Titel, Saal)</p></li>
<li><p>Lehrt(ProfName, VL_ID)</p></li>
<li><p>Hört(Matrikel,VL_ID)</p></li>
</ul>
<p>Gesucht werden in diesem Beispiel die unterschiedlichen Semester aller Studierenden, die eine Vorlesung eines Professors des Jahrgangs 1960 in Hörsaal 1 hören.<br>
Zunächst muss überlegt werden, welche Relationen benötigt werden. Eine Bedingung ist, dass es Hörsaal 1 sein muss, in dem die Vorlesung gehört wird. Das Attribut Saal befindet sich in der Vorlesungsrelation (VL).
Der Jahrgang des Professors ist eine weitere Bedingung. Dafür wird die Professorrelation (Prof) benötigt.
Die Professorrelation lässt sich mit der Vorlesungsrelation über die Lehrtrelation (Lehrt) verbinden, da letztere aus jeweils einem Attribut der anderen beiden Relationen besteht.
Ansonsten wird nach den Semestern der Studierenden gefragt. Das Attribut Semester befindet sich in der Studierendenrelation (Stud). Um die Studierendenrelation mit den anderen Relationen zu kombinieren, benötigt man die Hörtrelation (Hört).
<br>
Nach dem Finden aller benötigten Relationen können nun die Selektionen auf den jeweiligen Relationen ausgeführt werden. Eine Bedingung war, dass der Professor vom Jahrgang 1960 sein muss. Diese Selektion wird direkt auf der Professorrelation ausgeführt. Die Bedingung, dass es Saal 1 ist, wird auf der gejointen Professor-, Lehrt- und Vorlesungsrelation durchgeführt. Dann werden die Hört- und die Studierendenrelation gejoint, um an die Semester der Studierenden zu kommen. Zum Schluss wird die Ergebnisrelation auf das Semester projiziert.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{Sem}\)</span>(((<span class="math notranslate nohighlight">\(\sigma_{Saal=1}\)</span>(((<span class="math notranslate nohighlight">\(\sigma_{GebJahr = 1960}\)</span>(Professor))⋈Lehrt)⋈VL)⋈Hört)⋈Stud))</p></li>
</ul>
</div>
<div class="section" id="umbenennung-rename-rho">
<h3><span class="section-number">8.2.13. </span>Umbenennung (rename, <span class="math notranslate nohighlight">\(\rho\)</span>)<a class="headerlink" href="#umbenennung-rename-rho" title="Permalink to this headline">¶</a></h3>
<p>Die Umbenennung ist ein unärer Operator. Sie dient zur Kontrolle der Schemata und bietet  eine Möglichkeit einfachere Verknüpfungen anzuwenden. <br>
In dem Beispiel wird eine Relation R in S und die Attribute in der neuen Relation in A1 bis An umbenannt:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{S(A1,…,An)}\)</span>( R )</p></li>
</ul>
<p>Hätte man das Selbe ohne die Attribute der neuen Relation, würde man nur die Relation umbenennen:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{S(R)}\)</span></p></li>
</ul>
<p>Die Umbenennung ermöglicht weitere Operationen.<br>
Wenn mehrere Tabellen, die die gleichen Daten besitzen, zusammengeführt werden sollen, benötigen sie die gleichen Schemata für die Mengenoperationen (Vereinigungen, Schnittmenge …). Eine Umbennung kann ein gleiches Schema herbeiführen. <br>
Bei Joins, wo bisher kartesische Produkte verwendet wurden, können mit einer Umbenennung die unterschiedlichen Attribute gleich benannt und darüber gejoint werden. <br>
Bei kartesischen Produkten, bei denen bisher Joins ausgeführt wurden, können gleiche Attribute unterschiedlich genannt werden.</p>
<p>In diesem Beispiel zum Operator Umbenennung sollen zwei Relationen R und S mittels dem Kreuzprodukt verbunden werden. Damit die Attribute B nicht gleich heißen, wird das B aus der S-Relation in X umbenannt.</p>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(R \times \rho_{s(X,C,D)}(S)\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>X</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
<p>Alternativ können die Attribute der Ergebnisrelation erst nach dem Bilden des Kreuzproduktes von R und S umbenannt werden. Vor der Umbenennung sind die Namen der Attribute A, R.B., S.B, C, D und nach der Umbennung A, B, X, C, D.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{S(A,B,X,C,D)}\)</span>(R <span class="math notranslate nohighlight">\(\times\)</span> S)</p></li>
</ul>
</div>
<div class="section" id="unabhangigkeit-und-vollstandigkeit">
<h3><span class="section-number">8.2.14. </span>Unabhängigkeit und Vollständigkeit<a class="headerlink" href="#unabhangigkeit-und-vollstandigkeit" title="Permalink to this headline">¶</a></h3>
<p>Man hat eine minimale Menge von Operationen, die die Relationenalgebra bilden. Mittels diesen Operationen kann auf alles wie z.B Joins, Schnittmengen, usw. abgebildet werden. Dazu gehören:</p>
<ul class="simple">
<li><p>π, σ, <span class="math notranslate nohighlight">\(\times\)</span> , −, ∪ (und r)</p></li>
</ul>
<p>Unabhängigkeit bedeutet, dass kein Operator dieser Menge weggelassen werden kann ohne die Vollständigkeit zu verlieren. Wäre die Menge nicht mehr vollständig und könnte nicht mehr auf alle Operatoren abgebildet werden. <br>
Zum Beispiel sind der Natural Join, Join und die Schnittmenge redundant. Sie können durch andere Operatoren dargestellt werden:</p>
<ul class="simple">
<li><p>R <span class="math notranslate nohighlight">\(\cap\)</span> S = R − (R − S)</p></li>
<li><p>R ⋈_C S = <span class="math notranslate nohighlight">\(\sigma_C\)</span>(R <span class="math notranslate nohighlight">\(\times\)</span> S)</p></li>
<li><p>R ⋈ S = <span class="math notranslate nohighlight">\(\pi_{L}\)</span>(<span class="math notranslate nohighlight">\(\sigma_{R.A1=S.A1 AND … AND R.An=S.An}\)</span>(R <span class="math notranslate nohighlight">\(\times\)</span> S))</p></li>
</ul>
<p>Dennoch werden redundante Operatoren wie der Join häufig verwendet. Der Grund dafür ist die Übersichtlichkeit der Ausdrücke, wie man sehr gut am Beispiel für den natürlichen Join sehen kann.</p>
</div>
<div class="section" id="vorschau-zu-optimierung">
<h3><span class="section-number">8.2.15. </span>Vorschau zu Optimierung<a class="headerlink" href="#vorschau-zu-optimierung" title="Permalink to this headline">¶</a></h3>
<p>Um Optimierung zu betreiben, müssen für die vorhandenen Ausdrücke äquivalente Umformungen bekannt sein, mit denen man sie gegebenenfalls austauschen kann.
Dazu ein paar Beispiele für algebraische Regeln bei der Transformation:<br>
<br>
R gejoint mit S ist das Gleich wie S gejoint mit R. Die Reihenfolge der Attribute ist beim Tauschen von R und S eventuell anders. Kann im Nachhinein aber noch umsortiert werden.</p>
<ul class="simple">
<li><p>R ⋈ S = S ⋈ R</p></li>
</ul>
<p>Es gilt die Assoziativität. Die Reihenfolge der Klammerung kann beliebig getauscht werden. Das Ergebnis ändert sich auch dabei nicht.</p>
<ul class="simple">
<li><p>(R ⋈ S) ⋈ T = R ⋈ (S ⋈ T)</p></li>
</ul>
<p>Wenn man zwei Projektionen nacheinander durchführt und die äußere Projektion eine Teilmenge der inneren Projektion ist, kann die innere Projektion weggelassen werden.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho_{Y}(\rho_{X}(R)) = \rho_{Y}(R)\)</span></p>
<ul>
<li><p>Falls Y ⊆ X</p></li>
</ul>
</li>
</ul>
<p>Angenommen man hat zwei Selektionen auf der gleichen Relation R. Dann kann die Reihenfolge beider Selektionen verändert werden. Alternativ können beide Selektionen auch als ein Ausdruck zusammengefasst und verknüpft werden. Das Ergebnis bleibt immer gleich, aber je nachdem was man zuerst ausführt können unterschiedliche Kosten entstehen.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sigma_{A=a}(\sigma_{B=b}(R))= \sigma_{B=b}(\sigma_{A=a}(R)) [ = \sigma_{B=b\wedge A=a}(R) ]\)</span></p></li>
</ul>
<p>Das Tauschen von einer Projektion mit einer Selektion ist möglich, sofern das Attribut A in X enthalten ist.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\pi_{X}(\sigma_{A=a}(R)) = \sigma_{A=a}(\pi_{X}(R))\)</span></p>
<ul>
<li><p>Falls A ⊆ X</p></li>
</ul>
</li>
</ul>
<p>Die Selektion auf einer Vereinigung ist das Gleiche wie Selektionen auf den einzelnen Relationen, die dann vereinigt werden.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sigma_{A=a}(R ∪ S) = \sigma_{A=a}(R) ∪ \sigma_{A=a}(S)\)</span></p></li>
</ul>
<p>Der Optimierer fragt sich jedes Mal welche Seite besser bei der jetzigen Ausführung geeignet ist und wählt diese dann aus.</p>
</div>
</div>
<div class="section" id="operatoren-auf-multimengen">
<h2><span class="section-number">8.3. </span>Operatoren auf Multimengen<a class="headerlink" href="#operatoren-auf-multimengen" title="Permalink to this headline">¶</a></h2>
<p>Mit dem Wissen über die Basisoperatoren der Relationalen Algebra, kann nun genauer auf die Multimengen eingegangen werden.</p>
<div class="section" id="motivation">
<h3><span class="section-number">8.3.1. </span>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h3>
<p>Mengen sind ein natürliches Konstrukt. Sie enthalten keine Duplikate. Mit dieser Annahme kann schnell eine Schlussfolgerung über einen Datensatz gezogen werden. In der Realität kommen in den Tabellen aber häufig Duplikate vor. Kommerzielle DBMS basieren daher fast nie nur auf Mengen und aus diesem Grund erlauben  sie Multimengen. Eine Multimenge (bag, multiset) kann im Gegensatz zu einer Menge Duplikate enthalten.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p>Das Beispiel zeigt eine Multimenge, da (1,2) mehr als einmal in der Relation vorkommt. Die Reihenfolge der Tupel ist weiter unwichtig.</p>
</div>
<div class="section" id="effizienz-durch-multimengen">
<h3><span class="section-number">8.3.2. </span>Effizienz durch Multimengen<a class="headerlink" href="#effizienz-durch-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Bei manchen Operationen kann man durch die Nutzung von Multimengen Effizienz gewinnen.</p>
<p>Bei einer Vereinigung kann man die Daten direkt „aneinanderhängen“.
Bei einer Projektion kann man einfach die Attributwerte „abschneiden“. Es muss nicht wie bei Mengen sichergestellt werden, dass die Projektion keine Duplikate hat. Somit muss auch keine Duplikatsuchstrategie implementiert werden. <br>
<br>
Die Suche nach Duplikaten ist sehr teuer. Jedes Tupel im Ergebnis muss mit jedem anderen Tupel verglichen werden. Die Kosten sind O(n²), nicht sehr effizient.<br>
Eine Strategie effizienter nach Duplikaten zu suchen wäre es, alle Attribute zu sortieren. Die Kosten für eine Sortierung liegen in O(n log n) und sind somit günstiger als der Vergleich zuvor. Da man davon ausgeht, dass identische Tupel hintereinander in der sortierten Tabelle liegen, kann man die Tabelle nochmal durchgehen und dann Duplikate entfernen.<br>
<br>
Bei der Aggregation kann eine Duplikateliminierung sogar schädlich bzw. unintuitiv sein. Angenommen man berechnet den Durchschnitt von A (AVG(A)) und bildet zunächst eine Projektion auf A. Das Ergebnis der Projektion in der Mengensemantik ist (1,3). Wohingegen das Ergebnis in der Mutlimengensemantik (1,3,1,1) ist. Häufig ist bei der Berechnung von einem Durchschnitt der Durchschnitt aller Werte gemeint. Die Mengensemantik kann also Verwirrung verursachen und die Betrachtung von Multimengen wäre sinnvoller.</p>
<p>Wenn in dem Beispiel eine Projektion auf (A,B) ausgeführt wird, erhält man in der Mutlimengensemantik alle Tupel aus (A,B). In der Mengensemantik wären es nur (1,2) und (3,4), ohne deren Duplikate.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vereinigung-auf-multimengen">
<h3><span class="section-number">8.3.3. </span>Vereinigung auf Multimengen<a class="headerlink" href="#vereinigung-auf-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Seien R und S jeweils eine Multimenge. Ein Tupel t erscheint n-mal in R und m-mal in S. Ein Tupel t erscheint in R <span class="math notranslate nohighlight">\(\cup\)</span> S genau (n+m) mal.<br>
Im Beispiel kommt das Tupel (1,2) in R 3-mal und S nur 1-mal vor. Somit erscheint in R <span class="math notranslate nohighlight">\(\cup\)</span> das Tupel n+m = 3+1 = 4-mal.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
</table>
<p><span class="math notranslate nohighlight">\(R \cup S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="schnittmenge-auf-multimengen">
<h3><span class="section-number">8.3.4. </span>Schnittmenge auf Multimengen<a class="headerlink" href="#schnittmenge-auf-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Seien R und S jeweils eine Multimenge.
Ein Tupel t erscheint n-mal in R und m-mal in S. <br>
Das Tupel t erscheint in R <span class="math notranslate nohighlight">\(\cap\)</span> S, dann genau min(n,m) mal.<br>
Das Tupel (1,2) kommt in Relation R 3-mal und in S 1-mal vor. Somit erscheint es in R <span class="math notranslate nohighlight">\(\cap\)</span> S genau min(3,1) = 1-mal.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
</table>
<p><span class="math notranslate nohighlight">\(R\cap S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="differenz-auf-multimengen">
<h3><span class="section-number">8.3.5. </span>Differenz auf Multimengen<a class="headerlink" href="#differenz-auf-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Seien R und S jeweils eine Multimenge. Ein Tupel t erscheint n-mal in R und m-mal in S. <br>
Das Tupel t erscheint in R − S dann genau max(0, n−m) mal.
Falls t öfter in R als in S vorkommt, bleiben n−m t übrig.
Falls t öfter in S als in R vorkommt, bleibt kein t übrig, da es keine Negativtupel gibt.
Jedes Vorkommen von t in S eliminiert ein t in R.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
</table>
<p><span class="math notranslate nohighlight">\(R -S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(S-R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="projektion-und-selektion-auf-multimengen">
<h3><span class="section-number">8.3.6. </span>Projektion und Selektion auf Multimengen<a class="headerlink" href="#projektion-und-selektion-auf-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Bei der Projektion auf Multimengen können neue Duplikate entstehen. Diese werden nicht entfernt. Bei der Projektion (<span class="math notranslate nohighlight">\(\pi_{A,B}(R)\)</span>) im Beispiel werden daher die Duplikate des Tupels (1,2) nicht entfernt.
<br>
Bei der Selektion auf Mutlimengen wird die Selektionsbedingung auf jedes Tupel einzeln und unabhängig angewandt. Die schon vorhandenen Duplikate bleiben erhalten, sofern sie beide selektiert bleiben. Im Beispiel <span class="math notranslate nohighlight">\(\sigma_{C\geq6}(R)\)</span> wird somit nur das Tupel (1,2,5) entfernt, aber das Duplikat von (1,2,7) bleibt erhalten in der Ergebnisrelation.</p>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>7</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\pi_{A,B}(R)\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\sigma_{C\geq6}(R)\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>7</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="kreuzprodukt-auf-multimengen">
<h3><span class="section-number">8.3.7. </span>Kreuzprodukt auf Multimengen<a class="headerlink" href="#kreuzprodukt-auf-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Seien R und S jeweils eine Multimenge. Ein Tupel t erscheint n-mal in R und ein Tupel u erscheint m-mal in S.<br>
Das Tupel tu erscheint in R <span class="math notranslate nohighlight">\(\times\)</span> S dann genau n·m-mal.</p>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>5</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(R \times S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>R.B</p></th>
<th class="head"><p>S.B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="joins-auf-multimengen">
<h3><span class="section-number">8.3.8. </span>Joins auf Multimengen<a class="headerlink" href="#joins-auf-multimengen" title="Permalink to this headline">¶</a></h3>
<p>Bei Joins auf Multimengen gibt es keine großen Überraschungen. Der natürliche Join verbindet wieder zwei Relationen wo die Werte gleicher Attribute identisch sind. Der Theta-Join joint die Tupelpaare, bei denen die Selektionsbedingung erfüllt ist.</p>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>5</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(R⋈S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(R⋈_{R.B&lt;S.B}S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>R.B</p></th>
<th class="head"><p>S.B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="erweiterte-operatoren">
<h2><span class="section-number">8.4. </span>Erweiterte Operatoren<a class="headerlink" href="#erweiterte-operatoren" title="Permalink to this headline">¶</a></h2>
<p>Die erweiterten Operatoren machen teilweise nur Sinn je nachdem, ob sie für Mengen oder für Multimengen definiert sind. Meistens ergibt sich aus dem Kontext welche Semantik vorliegt.</p>
<div class="section" id="uberblick-uber-erweiterungen">
<h3><span class="section-number">8.4.1. </span>Überblick über Erweiterungen<a class="headerlink" href="#uberblick-uber-erweiterungen" title="Permalink to this headline">¶</a></h3>
<p>Eine kurze Übersicht zu den erweiterten Operatoren:</p>
<ul class="simple">
<li><p>Duplikateliminierung</p></li>
<li><p>Aggregation</p></li>
<li><p>Gruppierung</p></li>
<li><p>Sortierung</p></li>
<li><p>Outer Join</p></li>
<li><p>Outer Union</p></li>
<li><p>Semijoin</p></li>
<li><p>(Division)</p></li>
</ul>
</div>
<div class="section" id="duplikateliminierung-duplicate-elimination-delta">
<h3><span class="section-number">8.4.2. </span>Duplikateliminierung (duplicate elimination, <span class="math notranslate nohighlight">\(\delta\)</span>)<a class="headerlink" href="#duplikateliminierung-duplicate-elimination-delta" title="Permalink to this headline">¶</a></h3>
<p>Eine Duplikateliminierung wandelt eine Multimenge in eine Menge um, indem sie alle Kopien von Tupeln löscht. Sie kann auch auf Mengen angewandt werden, aber es würde das Ergebnis nicht ändern. Strenggenommen ist die Duplikateliminierung unnötig, da sie der Mengensemantik der relationalen Algebra entspricht.</p>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>a</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>b</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>c</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>d</p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(\delta(\pi_{A,B}(R))\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="aggregation">
<h3><span class="section-number">8.4.3. </span>Aggregation<a class="headerlink" href="#aggregation" title="Permalink to this headline">¶</a></h3>
<p>Eine Aggregation fasst die Werte einer Spalte zusammen.
Es ist eine Operation auf einer Menge oder Multimenge atomarer Werte (nicht auf Tupeln). Je nach Kontext kann die Mengensemantik oder die Multimengensemantik mehr Sinn machen.
Bei einer Aggregation gehen die Null-Werte in der Regel nicht mit in die Berechnung ein. <br>
Wie in Excel gibt es verschiedene Aggregationsoperatoren. Je nach Datenbanksystem kann es auch weitere Operatoren geben.</p>
<ul class="simple">
<li><p>Summe (SUM)</p></li>
<li><p>Durchschnitt (AVG)<br>
Auch: STDDEV und VARIANCE</p></li>
<li><p>Minimum (MIN) und Maximum (MAX)<br>
Für nicht-numerische Werte ist es das Maximum bzw. Minimum lexikographischer Ordnung.</p></li>
<li><p>Anzahl (COUNT)<br>
Die doppelten Werte gehen bei der Anzahl auch doppelt ein.<br>
Angewandt auf ein beliebiges Attribut ergibt dies die Anzahl der Tupel in der Relation.<br>
Dabei werden Zeilen mit NULL-Werten in der Regel mitgezählt.</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(R\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>SUM(B) = 10</p></li>
<li><p>AVG(A) = 1,5</p></li>
<li><p>MIN(A) = 1</p></li>
<li><p>MAX(B) = 4</p></li>
<li><p>COUNT(A) = 4</p></li>
<li><p>COUNT(B) = 4</p></li>
</ul>
<p>Zu den verschiedenen Aggregationen hier ein Beispiel anhand einer Film Tabelle:</p>
<p>Film</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>Typ</p></th>
<th class="head"><p>StudioName</p></th>
<th class="head"><p>SchauspName</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>Farbe</p></td>
<td><p>Fox</p></td>
<td><p>Sharon Stone</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
<td><p>Farbe</p></td>
<td><p>Disney</p></td>
<td><p>Sharon Stone</p></td>
</tr>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>Farbe</p></td>
<td><p>Fox</p></td>
<td><p>Arnold</p></td>
</tr>
<tr class="row-odd"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>121</p></td>
<td><p>s/w</p></td>
<td><p>Paramount</p></td>
<td><p>Johnny Depp</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>MAX(Jahr): Jüngster Film</p></li>
<li><p>MIN(Länge): Kürzester Film</p></li>
<li><p>SUM(Länge): Summe der Filmminuten</p></li>
<li><p>AVG(Länge): Durchschnittliche Filmlänge</p></li>
<li><p>MIN(Titel): Alphabetisch erster Film</p></li>
<li><p>COUNT(Titel): Anzahl Filme</p></li>
<li><p>COUNT(StudioName): Anzahl Filme</p></li>
<li><p>AVG(SchauspName): syntax error</p></li>
</ul>
</div>
<div class="section" id="gruppierung-group-gamma">
<h3><span class="section-number">8.4.4. </span>Gruppierung (group, <span class="math notranslate nohighlight">\(\gamma\)</span>)<a class="headerlink" href="#gruppierung-group-gamma" title="Permalink to this headline">¶</a></h3>
<p>Die Gruppierung spielt eine wichtige Rolle im Zusammenhang mit Aggregationen. Sehr oft werden für einzelne Elemente in der Relation Aggregationen durchgeführt. <br>
<br>
Die Gruppierung ist die Partitionierung der Tupel einer Relation gemäß ihrer Werte in einem Attribut oder mehreren Attributen.
Ihr Hauptzweck ist die Aggregation auf Teilen einer Relation (Gruppen).<br>
<br>
Beispielsweise ist eine Film Relation gegeben:</p>
<ul class="simple">
<li><p>Film(Titel, Jahr, Länge, inFarbe, StudioName, ProduzentID)</p></li>
</ul>
<p>Gesucht werden die Gesamtminuten pro Studio:</p>
<ul class="simple">
<li><p>Gesamtminuten(StudioName, SummeMinuten)</p></li>
</ul>
<p>Um das Gesuchte zu erhalten, wird zunächst nach StudioName gruppiert. Danach wird in jeder Gruppe die Länge der Filme summiert und letztendlich die Paare (Studioname, Summe) ausgegeben.</p>
<p>Der Operator <span class="math notranslate nohighlight">\(\gamma\)</span> steht für die Gruppierung. <span class="math notranslate nohighlight">\(\gamma_L\)</span>( R ) ist eine Gruppierung auf einer Relation R, wobei L eine Menge von Attributen ist. Ein Element in L ist entweder ein Gruppierungsattribut nach dem gruppiert wird oder ein Aggregationsoperator auf ein Attribut von R (inkl. neuen Namen für das aggregierte Attribut).
<br>
Das Ergebnis wird wie folgt konstruiert:
<br></p>
<ul class="simple">
<li><p>Die Relation R wird in Gruppen partitioniert, wobei jede Gruppe gleiche Werte im Gruppierungsattribut hat. Falls kein Gruppierungsattribut angegeben wird, ist ganz R die Gruppe</p></li>
<li><p>Für jede Gruppe wird ein Tupel erzeugt, mit:</p>
<ul>
<li><p>Wert der Gruppierungsattribute</p></li>
<li><p>Aggregierte Werte über alle Tupel der Gruppe</p></li>
</ul>
</li>
</ul>
<p>Im Folgenden betrachten wir einige Beispiele, wie Gruppierungen verwendet werden:</p>
<p>Beispiel 1:</p>
<p>Film</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Titel</p></th>
<th class="head"><p>Jahr</p></th>
<th class="head"><p>Länge</p></th>
<th class="head"><p>Typ</p></th>
<th class="head"><p>StudioName</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Total Recall</p></td>
<td><p>1990</p></td>
<td><p>113</p></td>
<td><p>Farbe</p></td>
<td><p>Fox</p></td>
</tr>
<tr class="row-odd"><td><p>Basic Instinct</p></td>
<td><p>1992</p></td>
<td><p>127</p></td>
<td><p>Farbe</p></td>
<td><p>Disney</p></td>
</tr>
<tr class="row-even"><td><p>Dead Man</p></td>
<td><p>1995</p></td>
<td><p>90</p></td>
<td><p>s/w</p></td>
<td><p>Paramount</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Durchschnittliche Filmlänge pro Studio:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\gamma_{Studio, AVG(Länge)→Durchschnittslänge}\)</span>(Film)</p></li>
<li><p>Unser Gruppenattribut ist Studio und wir aggregieren über das Attribut Länge, um den Durchschnitt zu ermitteln und benennen zuletzt AVG(Länge) zu Durchschnittslänge um</p></li>
</ul>
</li>
</ul>
<p><br><br></p>
<ul class="simple">
<li><p>Anzahl der Filme pro Schauspieler</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\gamma_{SchauspName, Count(Titel)→Filmanzahl}\)</span>(Film)</p></li>
<li><p>Unser Gruppierungsattribut ist SchauspName und wir betrachten für jede/n Schaupspieler*in alle Filme und zählen diese, zuletzt wird für bessere Handhabung wieder unbenannt</p></li>
</ul>
</li>
</ul>
<p><br><br></p>
<ul class="simple">
<li><p>Durchschnittliche Anzahl der Filme pro Schauspieler</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\gamma_{AVG(Filmanzahl)}(\gamma_{SchauspName, Count(Titel)→Filmanzahl}\)</span>(Film))</p></li>
<li><p>In diesem Beispiel sehen wir zwei verschachtelte Gruppierungen. Zuerst zähllen wir alle Filme pro Schauspieler*in (Ausdruck wie oben) und über die daraus resultierende Relation, berechnen wir den Durchschnitt der Filmanzahl</p></li>
</ul>
</li>
</ul>
<p><br><br>
Als Übung können sie zu Hause die folgenden Beispiele in Ausdrücke der Relationalen Algebra umwandeln:</p>
<ul class="simple">
<li><p>Anzahl Schauspieler pro Film</p></li>
<li><p>Durchschnittliche Anzahl der Schauspieler pro Film</p></li>
<li><p>Studiogründung: Kleinstes Jahr pro Studio</p></li>
</ul>
<p>Beispiel 2:</p>
<p>Betrachten wir nun die Relation SpieltIn(Titel, Jahr, SchauspName). Wir möchten für jeden Schauspieler*in , der/die in mindestens 3 Filmen mitspielte, das Jahr des ersten Filmes.
<br>
Um das gewünschte Ergebnis zu bekommen, muss nach SchauspName gruppiert werden, danach das Minimum von Jahr und der Count von Titel gebildet werden. Anschließend selektieren wir nach Anzahl der Filme und projezieren auf SchauspName und Jahr.
<br><br>
<span class="math notranslate nohighlight">\(\pi_{SchauspName, MinJahr}(\sigma_{AnzahlTitel≥3}(\gamma_{SchauspName, MIN(Jahr)→MinJahr, COUNT(Titel)→AnzahlTitel}(SpieltIn)))\)</span></p>
<p>Beispiel 3:</p>
<p>Wir haben erneut die Relation SpieltIn(Titel, Jahr, SchauspName) gegeben und möchten für jeden Schauspieler*in , der/die in mindestens 3 Filmen mitspielte, das Jahr des ersten Filmes <strong>und</strong> zusätzlich den Titel dieses Films. Die  Idee ist genauso wie vorher in Beispiel 2. Jedoch wird anschließend ein Self-Join durchgeführt, um Filmtitel zu bekommen. Ganz zum Schluss wird nach SchauspName gruppiert, um die Gruppe auf einen Film zu reduzieren.
<br><br>
<span class="math notranslate nohighlight">\(\gamma_{SchauspName, MIN(MinJahr)→MinJahr, MIN(Titel)→Titel}( (SpieltIn) ⋈_{SchauspName = SchauspName, MinJahr = Jahr}
(\pi_{SchauspName, MinJahr}(\sigma_{AnzahlTitel≥3}(
\gamma_{SchauspName, MIN(Jahr)→MinJahr, COUNT(Titel)→AnzahlTitel}(SpieltIn)
) ) )
)\)</span></p>
<p>Beispiel 4 mit komplexen Ausdrücken und Gruppierungen:<br>
<br>
Es sind folgende Relationen gegeben:</p>
<ul class="simple">
<li><p>Stud(Matrikel, Name, Semester)</p></li>
<li><p>Prof(ProfName, Fachgebiet, GebJahr)</p></li>
<li><p>VL(VL_ID, Titel, Saal)</p></li>
<li><p>Lehrt(ProfName, VL_ID)</p></li>
<li><p>Hört(Matrikel,VL_ID)</p></li>
</ul>
<p>Gesucht werden die Fachgebiete von Professor*innen, die VL halten, welche weniger als drei Hörer*Innen haben. Zunächst zählen wir in der Hört-Relation die Anzahl der Matrikelnummern und selektieren, jene, die weniger als drei haben. Die resultierende Relation daraus joinen wir mit Prof und Lehrt. Anschließend gruppieren wir nach Fachgebiet. Die Gruppierung fungiert hier wie eine Projektion, es werden jedoch noch Duplikate entfernt.</p>
<ul class="simple">
<li><p>Mit Gruppierung: <span class="math notranslate nohighlight">\(\gamma_{Fachgebiet}\)</span>( (Prof ⋈ Lehrt) ⋈ (<span class="math notranslate nohighlight">\(\sigma_{ COUNT &lt; 3(gVL_ID,COUNT(Matrikel)-&gt; COUNT}\)</span>(Hört)))</p></li>
<li><p>Alternativ: <span class="math notranslate nohighlight">\(\pi_{Fachgebiet}\)</span>( (Prof ⋈ Lehrt) ⋈ (<span class="math notranslate nohighlight">\(\sigma_{ COUNT &lt; 3(gVL_ID,COUNT(Matrikel)-&gt; COUNT}\)</span>(Hört)))</p></li>
</ul>
</div>
<div class="section" id="sortierung-sort-tau">
<h3><span class="section-number">8.4.5. </span>Sortierung (sort, <span class="math notranslate nohighlight">\(\tau\)</span>)<a class="headerlink" href="#sortierung-sort-tau" title="Permalink to this headline">¶</a></h3>
<p><span class="math notranslate nohighlight">\(\tau_L\)</span>( R ) sortiert die Realtion R, wobei L eine Attributliste aus R ist. Sei L = (A1,A2,…,An) wird zuerst nach A1, bei gleichen A1 nach A2 usw. sortiert.
<br><br>
<strong>Wichtig</strong>: Das Ergebnis der Sortierung ist keine Menge, sondern eine Liste. Daher sollte die Sortierung der letzte Operator eines Ausdrucks sein. Ansonsten würden wieder Mengen entstehen und die Sortierung wäre verloren. Trotzdem kann es in DBMS vorteilhaft sein manchmal auch zwischendurch zu sortieren.</p>
</div>
<div class="section" id="semi-join">
<h3><span class="section-number">8.4.6. </span>Semi-Join (⋊)<a class="headerlink" href="#semi-join" title="Permalink to this headline">¶</a></h3>
<p>In den vorherigen Kapiteln haben wir den Theta- und Natural-Join kennengelernt. Nun wollen wir in den folgenden Kapiteln weitere Joinformen kennenlernen. Wir starten mit dem Semi-Join.
<br><br>
Formal: Wir haben die Relationen R(A) und S(B) gegeben.
<br>
R ⋉ S : = <span class="math notranslate nohighlight">\(\pi_A\)</span>(R⋈S)
<br>
= <span class="math notranslate nohighlight">\(\pi_A\)</span>( R ) ⋈<span class="math notranslate nohighlight">\(\pi_{A\cap B}\)</span>(S)
<br>
= R⋈<span class="math notranslate nohighlight">\(\pi_{A\cap B}\)</span>(S)
<br><br>
Ein Semi-Join ist eine Projektion der Attribute von R, hier A, auf den Natural-Join zwischen R und S. Bzw. der Join zwischen den Attributen von R und den Attributen von S, die eine Überschneidung mit denen von R haben. Zuletzt kann eine Semi-Join auch als der Join zwischen R und dem Teil von S sein, welcher eine Überschneidung mit R hat. Die Definition ist analog für Theta-Joins.
<br><br>
In Worten: Wir joinen R und S, aber nur die Attribute von R sind für uns von Wichtigkeit. Das Ergebnis ist <strong>nicht</strong> wieder gleich R, da wir nur jene Attribute von R ausgeben, die auch joinbar mit S sind, ohne S mitauszugeben.
<br>
Wichtig: Der Semi-Join ist natürlich nicht kommutativ: R ⋉ S ≠ S ⋉ R.</p>
<p><strong>Beispiel 1</strong></p>
<p>Semi-Joins sind vorallem interessant, wenn Datenbankberechnungen auf verteilten Systemen stattfinden, da so kontrolliert werden kann wie viele der Daten weitergegeben werden. Betrachten wir zur Veranschaulichung ein Beispiel. Angenommen wir haben einen Server, der die Relation R enthält und einen anderen Server, der die Relation S enthält gegeben. Nun möchten wir R ⋉ S durchführen. Eine Möglichkeit wäre es, das Site 1 die komplette Relation S anfordert und den Semi-Join dann durchführt. Jedoch interessiert uns bei S nur das Joinattribut und wir schicken, aber die gesamte Relation, also eine Größe von Länge der Daten multipliziert mit der Länge der Tupel. Ein anderer Weg wäre nur die Joinattribute von S, in diesem Beispiel ID, zu schicken, welches die Kommunikationskosten deutlich verringern würde. Hier ist natürlich vorausgesetzt, dass das System weiß, dass ein Semi-Join durchgeführt werden soll.</p>
<p><img alt="title" src="../_images/semijoin1.jpg" /></p>
<p><strong>Beispiel 2</strong></p>
<p>Betrachten wir nun einen “komplizierteren” Weg. Wir projezieren auf R und schicken die Joinattribute zu dem Server, auf welchem S liegt und semi-joinen diese. Nun wurde die Tupelanzahl schon verringert und wir schicken, das Ergebnis wieder zur Site 1 un joinen diese wieder mit R.</p>
<p><img alt="title" src="../_images/semijoin2.jpg" /></p>
<p><strong>Beispiel 3</strong></p>
<p>In unserem letzten Beispiel haben wir drei Server gegeben. Unser Ziel ist es, dass alle Attribute aus S und R in Site 1 enthalten sind. Der einfache Weg ist beide Relationen komplett rüberzuschicken und zu joinen. Ein anderer Weg wäre die IDs von S zum Server von R zu schicken und diese zu semi-joinen. Dann werden nur jene Tupel die joinbar mit S sind an unseren Zielserver geschickt. Zeitgleich kann ein Semi-Join zwischen S und den zu Site 0 geschickten IDs von R durchgeführt werden. Daraus resultieren jene Tupel von S die joinbar mit R sind und diese werden auf zum Zielserver geschickt. Zum Schluss werden die beiden Relationen verjoint. Die Frage die sich nun stellt, ist wie groß R und S sein müssen, s.d der “kompliziertere” Weg kostengünstiger ist.</p>
<p><img alt="title" src="../_images/semijoin3.jpg" /></p>
</div>
<div class="section" id="outer-joins-auszere-verbunde">
<h3><span class="section-number">8.4.7. </span>Outer Joins (Äußere Verbünde, |⋈|)<a class="headerlink" href="#outer-joins-auszere-verbunde" title="Permalink to this headline">¶</a></h3>
<p>Outer-Joins fungieren so wie wir es bei normalen Joins gewohnt sind, <strong>außer</strong> das „dangling tuples“ nun in das in das Ergebnis mitaufgenommen werden und mit Nullwerten (padding) aufgefüllt werden.
<br></p>
<ul class="simple">
<li><p>Nullwert: <span class="math notranslate nohighlight">\(\perp\)</span> bzw. null (≠ 0)
<br><br>
Bei einem Full outer join werden alle Tupel beider Operanden angegeben, bei Tupel die nicht sinnvol verjoint werden können, werden die “Lücken” mit Nullwerten aufgefüllt. Schreibweise: R |⋈| S.
<br><br>
Bei einem Left outer join (bzw. Right outer join) werden alle Tupel des linken (bzw. rechten) Operanden übernommen, und jene die nicht verjoint werden konnten, werden ebenfalls mit Nullwerten aufgefüllt. Schreibweise: R |⋈ S (bzw. R ⋈| S)
<br><br>
Der herkömmlicher Join wird auch „Inner join“ genannt.
<br>
<br>
In der Veranschaulichung 1, haben wir die Relationen R uns S gegeben:
<br></p></li>
<li><p>R⋈S</p>
<ul>
<li><p>Ergebnis besteht aus j1, f12 und j2
<br></p></li>
</ul>
</li>
<li><p>R |⋈ S</p>
<ul>
<li><p>Ergebnis besteht aus s1, u1, <span class="math notranslate nohighlight">\(\perp_1\)</span>, j1, f12 und j2
<br></p></li>
</ul>
</li>
<li><p>R ⋈| S</p>
<ul>
<li><p>Ergebnis besteht aus j1, f12, j2, s2, u2, <span class="math notranslate nohighlight">\(\perp_2\)</span>,
<br></p></li>
</ul>
</li>
<li><p>R |⋈| S</p>
<ul>
<li><p>Alle Attribute sind enthalten</p></li>
</ul>
</li>
</ul>
<a class="reference internal image-reference" href="../_images/outerjoin1.jpg"><img alt="../_images/outerjoin1.jpg" src="../_images/outerjoin1.jpg" style="width: 250px;" /></a>
</div>
<div class="section" id="outer-union">
<h3><span class="section-number">8.4.8. </span>Outer Union (⊎)<a class="headerlink" href="#outer-union" title="Permalink to this headline">¶</a></h3>
<p>Beim Outer Union werden inkompatible Schemata auch vereinigt. Das Schema besteht dann aus Vereinigung der Attributmengen, wobei fehlende Werte werden mit Nullwerten ergänzt werden. In dem Beispiel unten können nur die Attribute B, C vereinigt werden. Bei den restlichen Attributen A, D wird die fehlende Spalte mit Nullwerten aufgefüllt.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(R\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>A</strong></p></td>
<td><p><strong>B</strong></p></td>
<td><p><strong>C</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(S\)</span></p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>B</strong></p></td>
<td><p><strong>C</strong></p></td>
<td><p><strong>D</strong></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>3</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</table><p><span class="math notranslate nohighlight">\(R⊎S\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p><span class="math notranslate nohighlight">\(\perp\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p><span class="math notranslate nohighlight">\(\perp\)</span></p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p><span class="math notranslate nohighlight">\(\perp\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\perp\)</span></p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\perp\)</span></p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\perp\)</span></p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="division-division">
<h3><span class="section-number">8.4.9. </span>Division (division, /)<a class="headerlink" href="#division-division" title="Permalink to this headline">¶</a></h3>
<p>Der Divionsoperator wird typischerweise nicht als primitiver Operator unterstützt. Er kann jedoch bei speziellen Anfragen vorteilhaft sein.
<br>
Z.B möchten wir alle Segler*innen, die alle Segelboote reserviert haben finden. Hier haben wir eine Vorbedingung die gewissermaßen auf die Existenz von Tupeln in anderen Relationen voraussetzt.
<br>
Wir haben die Relation R(x,y) und die Relation S(y) gegeben.
<br></p>
<ul class="simple">
<li><p>R/S = { t <span class="math notranslate nohighlight">\(\in\)</span> R(x) | <span class="math notranslate nohighlight">\(\forall\)</span> y <span class="math notranslate nohighlight">\(\in\)</span> S <span class="math notranslate nohighlight">\(\exists\)</span> &lt;x, y&gt; <span class="math notranslate nohighlight">\(\in\)</span> R}</p>
<ul>
<li><p>R dividiert durch S, gibt jene Tupel aus R zurück, wo für alle y in S es &lt;x,y&gt; in R gibt.<br></p></li>
<li><p>R/S enthält alle x-Tupel (Segler*\innen), so dass es für jedes y-Tupel (Boot) in S ein xy-Tupel in R gibt.</p></li>
<li><p>Andersherum: Falls die Menge der y-Werte (Boote), die mit einem x-Wert (Segler*in) assoziiert sind, alle y-Werte in S enthält, so ist der x-Wert in R/S.</p></li>
</ul>
</li>
</ul>
<p><br><br>
Eine weitere Anfrage, die mit einer Division ausgedrückt werden kann ist: Hole die Namen von Angestellten, die an allen Projekten arbeiten.
<br>
Sinnvoller: Hole die Namen von Angestellten, die an allen Projekten arbeiten, in denen auch „Thomas Müller“
arbeitet.</p>
<p>Betrachten wir folgendes Beispiel zur Division. Relation A hat die Attribute sno und pno und die Relationenn B1, B2, B3 nur das Attribut pno. A/B1 enthält alle sno’s die in A mit den pno’s aus B1 auftauchen. Der Wert p2 taucht in A mit den sno’s s1, s2, s3 und s4 auf, folglich bildet sich A/B1 daraus. Das gilt analog für A/B2 und A/B3.</p>
<a class="reference internal image-reference" href="../_images/division1.jpg"><img alt="drawing" src="../_images/division1.jpg" style="width: 350px;" /></a>
<p>Die Division ist kein essentieller Operator,sondern lediglich nur eine nützliche Abkürzung. Ebenso wie Joins, aber Joins sind so üblich, dass Systeme sie speziell unterstützen. Die Idee um R/S zu berechnen sieht wei folgt aus: Berechne alle x-Werte, die nicht durch einen y-Wert in S „disqualifiziert“ werden.</p>
<ul class="simple">
<li><p>x-Wert ist disqualifiziert, falls man durch Anfügen eines y-Wertes ein xy-Tupel erhält, das nicht in R ist.</p></li>
<li><p>Disqualifizierte x-Werte: <span class="math notranslate nohighlight">\(\pi_{x}\)</span> ((<span class="math notranslate nohighlight">\(\pi_{x}\)</span>( R ) <span class="math notranslate nohighlight">\(\times\)</span> S) − R)</p></li>
</ul>
<p><br><br>
=&gt; R/S: <span class="math notranslate nohighlight">\(\pi_{x}\)</span>( R ) − alle disqualifizierten Tupel</p>
</div>
</div>
<div class="section" id="fragen">
<h2><span class="section-number">8.5. </span>Fragen<a class="headerlink" href="#fragen" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Die hier verwendete Version des Multiple-Choice-Trainers von EILD.nrw wird über GitHub-Pages gehostet und in das Skript eingebunden.</p></li>
<li><p>Alle Fragen und Kategorien befinden sich zurzeit in Überarbeitung und sind nicht final.</p></li>
<li><p>Für den vollen Funktionsumfang wird empfohlen einen auf Firefox basierten Browser zu nutzen.</p></li>
</ul>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="100%"
    height="800"
    src="https://luh-dbs.github.io/mct-trainer/#/quiz/categories/relationalealgebra"
    frameborder="0"
    allowfullscreen

></iframe>
</div></div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./08"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="../07/normalisierung.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">7. </span>Normalisierung</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../09/sql.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">9. </span>SQL</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Prof. Dr. Ziawasch Abedjan<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>