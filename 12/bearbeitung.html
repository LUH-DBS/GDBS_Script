
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>12. Bearbeitung &#8212; Online-Skript Grundlagen der Datenbanksysteme</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="11. Transaktionsmanagement" href="../11/transaktionen.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/DBIS_Kurzlogo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Online-Skript Grundlagen der Datenbanksysteme</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Grundlagen der Datenbanksysteme
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../01/einfuehrung.html">
   1. Einführung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../02/historie.html">
   2. Historie
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../03/architektur.html">
   3. Architektur
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/phasenmodell_datenbankentwurf.html">
   4. Phasenmodell für den Datenbankentwurf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../05/er_modellierung.html">
   5. ER-Modellierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../06/relationaler_entwurf.html">
   6. Relationaler Entwurf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../07/normalisierung.html">
   7. Normalisierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../08/relationale_algebra.html">
   8. Relationale Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../09/sql.html">
   9. SQL
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../10/integritaet_und_trigger.html">
   10. Integrität und Trigger
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../11/transaktionen.html">
   11. Transaktionsmanagement
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   12. Bearbeitung
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/LUH-DBS/GDBS_Script/main/?urlpath=tree/12/bearbeitung.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        
<button onclick="initThebeSBT()"
  class="headerbtn headerbtn-launch-thebe"
  data-toggle="tooltip"
data-placement="left"
title="Launch Thebe"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="headerbtn__text-container">Live Code</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/LUH-DBS/GDBS_Script"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F12/bearbeitung.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/12/bearbeitung.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parsen-der-anfrage">
   12.1. Parsen der Anfrage
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#syntaxanalyse">
     12.1.1. Syntaxanalyse
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eine-grammatik-fur-einen-teil-von-sql">
     12.1.2. Eine Grammatik für einen Teil von SQL
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parse-baum">
     12.1.3. Parse-Baum
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#prufung-der-semantik">
     12.1.4. Prüfung der Semantik
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vom-parse-baum-zum-operatorbaum">
     12.1.5. Vom Parse-Baum zum Operatorbaum
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#transformationsregeln-der-ra">
   12.2. Transformationsregeln der RA
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragebearbeitung-transformationsregeln">
     12.2.1. Anfragebearbeitung – Transformationsregeln
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragebearbeitung-beispiel">
     12.2.2. Anfragebearbeitung – Beispiel
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kommutativitat-und-assoziativitat">
     12.2.3. Kommutativität und Assoziativität
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#weitere-regeln">
     12.2.4. Weitere Regeln
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#optimierung">
   12.3. Optimierung
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragebearbeitung-optimierung">
     12.3.1. Anfragebearbeitung - Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#logische-optimierung">
     12.3.2. Logische Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#physische-optimierung">
     12.3.3. Physische Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#logische-optimierung-regelbasiert">
     12.3.4. Logische Optimierung – regelbasiert
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anwendung-der-transformationsregeln">
     12.3.5. Anwendung der Transformationsregeln
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aufspalten-der-selektionspradikate">
     12.3.6. Aufspalten der Selektionsprädikate
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#verschieben-der-selektionspradikate-pushing-selections">
     12.3.7. Verschieben der Selektionsprädikate „Pushing Selections“
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zusammenfassung-von-selektionen-und-kreuzprodukten-zu-joins">
     12.3.8. Zusammenfassung von Selektionen und Kreuzprodukten zu Joins
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optimierung-der-joinreihenfolge-kommutativitat-und-assoziativitat-ausnutzen">
     12.3.9. Optimierung der Joinreihenfolge: Kommutativität und Assoziativität ausnutzen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#was-hat-s-gebracht">
     12.3.10. Was hat´s gebracht?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#einfugen-von-projektionen">
     12.3.11. Einfügen von Projektionen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sqlite-explain">
     12.3.12. SQLite Explain
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kostenmodelle">
   12.4. Kostenmodelle
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kostenbasierte-optimierung">
     12.4.1. Kostenbasierte Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problemgrosze-suchraum">
     12.4.2. Problemgröße (Suchraum)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kostenmodell">
     12.4.3. Kostenmodell
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#statistiken">
     12.4.4. Statistiken
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kosten-von-operationen">
     12.4.5. Kosten von Operationen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selektivitat">
     12.4.6. Selektivität
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#selektivitat-schatzen">
       12.4.6.1. Selektivität schätzen
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selinger-style-optimization">
     12.4.7. Selinger-style“ Optimization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#join-selektivitat-selinger-style">
     12.4.8. Join Selektivität (Selinger Style)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#modelle-zum-besseren-schatzen-der-selektivitat">
     12.4.9. Modelle zum besseren Schätzen der Selektivität
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispiel-zu-histogrammen">
     12.4.10. Beispiel zu Histogrammen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kosten-weitere-komplikationen">
     12.4.11. Kosten – Weitere Komplikationen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ausblick-auf-dbs-ii">
     12.4.12. Ausblick auf DBS II
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#multiple-choice">
   12.5. Multiple Choice
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Bearbeitung</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parsen-der-anfrage">
   12.1. Parsen der Anfrage
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#syntaxanalyse">
     12.1.1. Syntaxanalyse
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eine-grammatik-fur-einen-teil-von-sql">
     12.1.2. Eine Grammatik für einen Teil von SQL
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parse-baum">
     12.1.3. Parse-Baum
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#prufung-der-semantik">
     12.1.4. Prüfung der Semantik
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vom-parse-baum-zum-operatorbaum">
     12.1.5. Vom Parse-Baum zum Operatorbaum
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#transformationsregeln-der-ra">
   12.2. Transformationsregeln der RA
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragebearbeitung-transformationsregeln">
     12.2.1. Anfragebearbeitung – Transformationsregeln
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragebearbeitung-beispiel">
     12.2.2. Anfragebearbeitung – Beispiel
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kommutativitat-und-assoziativitat">
     12.2.3. Kommutativität und Assoziativität
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#weitere-regeln">
     12.2.4. Weitere Regeln
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#optimierung">
   12.3. Optimierung
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anfragebearbeitung-optimierung">
     12.3.1. Anfragebearbeitung - Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#logische-optimierung">
     12.3.2. Logische Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#physische-optimierung">
     12.3.3. Physische Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#logische-optimierung-regelbasiert">
     12.3.4. Logische Optimierung – regelbasiert
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anwendung-der-transformationsregeln">
     12.3.5. Anwendung der Transformationsregeln
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aufspalten-der-selektionspradikate">
     12.3.6. Aufspalten der Selektionsprädikate
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#verschieben-der-selektionspradikate-pushing-selections">
     12.3.7. Verschieben der Selektionsprädikate „Pushing Selections“
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zusammenfassung-von-selektionen-und-kreuzprodukten-zu-joins">
     12.3.8. Zusammenfassung von Selektionen und Kreuzprodukten zu Joins
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optimierung-der-joinreihenfolge-kommutativitat-und-assoziativitat-ausnutzen">
     12.3.9. Optimierung der Joinreihenfolge: Kommutativität und Assoziativität ausnutzen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#was-hat-s-gebracht">
     12.3.10. Was hat´s gebracht?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#einfugen-von-projektionen">
     12.3.11. Einfügen von Projektionen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sqlite-explain">
     12.3.12. SQLite Explain
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kostenmodelle">
   12.4. Kostenmodelle
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kostenbasierte-optimierung">
     12.4.1. Kostenbasierte Optimierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problemgrosze-suchraum">
     12.4.2. Problemgröße (Suchraum)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kostenmodell">
     12.4.3. Kostenmodell
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#statistiken">
     12.4.4. Statistiken
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kosten-von-operationen">
     12.4.5. Kosten von Operationen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selektivitat">
     12.4.6. Selektivität
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#selektivitat-schatzen">
       12.4.6.1. Selektivität schätzen
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selinger-style-optimization">
     12.4.7. Selinger-style“ Optimization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#join-selektivitat-selinger-style">
     12.4.8. Join Selektivität (Selinger Style)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#modelle-zum-besseren-schatzen-der-selektivitat">
     12.4.9. Modelle zum besseren Schätzen der Selektivität
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispiel-zu-histogrammen">
     12.4.10. Beispiel zu Histogrammen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kosten-weitere-komplikationen">
     12.4.11. Kosten – Weitere Komplikationen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ausblick-auf-dbs-ii">
     12.4.12. Ausblick auf DBS II
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#multiple-choice">
   12.5. Multiple Choice
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="bearbeitung">
<h1><span class="section-number">12. </span>Bearbeitung<a class="headerlink" href="#bearbeitung" title="Permalink to this headline">#</a></h1>
<p><strong>Anfragebearbeitung – Grundproblem</strong> <br></p>
<p>Die Anfragen, die an eine Datenbank gestellt werden, sind deklarativ. Solche Anfragen können in SQL, aber auch in der Relationalen Algebra formuliert werden.
Mittels der Anfragen sagt man somit was man will, aber nicht wie man das bekommt, was man will.
Das Datenbanksystem findet von selbst heraus, wie es an das kommt, was man möchte.
Angenommen die Anfragen wären nicht deklarativ, dann müsste ein Programm geschrieben werden, das beispielsweise erst eine CSV-Datei durchgeht usw.
Stattdessen “sagt” man (deklarativ): Gebe alle Filme aus, die im Jahr 1996 produziert werden. <br>
<br>
Die Anfragen müssen in eine ausführbare (prozedurale) Form transformiert werden. Ein Ziel hierbei ist es, einen „QEP“ (prozeduraler Query Execution Plan) zu erhalten. Wichtig zu beachten ist die Effizienz des Programms. Es soll zum Einem schnell sein, aber zum Anderen auch wenige Ressourcen verbrauchen (CPU, I/O, RAM, Bandbreite), denn es wirkt sich stark auf den Energieverbrauch aus. <br></p>
<p><strong>Ablauf der Anfragebearbeitung</strong><br><br>
Gegeben ist zunächst eine Anfrage der Form: <br>
SELECT * FROM x WHERE …;</p>
<ol class="arabic simple">
<li><p>Parsing:<br>
Eine solche Anfrage wird zunächst mit Blick auf die Syntax geparst. Anschließend werden die Elemente auf korrekte Semantik überprüft und ein Parsebaum erstellt. Es wird herausgefunden auf welche Operationselemente die Anfrage abgebildet wird. <br>
<br></p></li>
<li><p>Wahl des logischen Anfrageplans:<br>
Im zweitem Schritt wird ein logischer Anfrageplan ausgewählt. In der Regel ist es ein Baum mit logischen Operatoren.<br>
Es gibt exponentiell viele Pläne, die man anhand der Elemente, die man in der Anfrage hat, erstellen kann. Natürlich lassen sich bestimme Kombinationen nicht darstellen. Das Grundproblem ist auch NP-Vollständig.<br>
Unter den verschiedenen Plänen muss der optimale Plan ausgewählt werden. Dabei gibt es verschiedene Optimierungsverfahren, die angewandt werden können.<br>
Mittels der logischen Optimierung können Operatoren im Plan hin- und hergeschoben werden.
Weitere Optimierungen können auch mit regelbasierten und kostenbasierten Optimierern durchgeführt werden. Diese basieren auf den Kosten der jeweiligen Operationen der Anfragen.<br>
<br></p></li>
<li><p>Wahl des physischen Anfrageplans:<br>
Für jede Operation, die momentan noch in deklarativer Form ist, muss nun eine Prozedur bzw. ein Programm mit physischen Operatoren ausgewählt werden. Dies sind unter anderem Algorithmen, Scan Operatoren oder auch JOIN-Implementierungen. <br>
Hierbei können physische Optimierungen angewandt werden.<br></p></li>
</ol>
<p>Am Ende wird der ausgewählte Anfrageplan ausgeführt.</p>
<a class="reference internal image-reference" href="../_images/ablauf_anfragebearbeitung.jpg"><img alt="drawing" src="../_images/ablauf_anfragebearbeitung.jpg" style="width: 300px;" /></a>
<section id="parsen-der-anfrage">
<h2><span class="section-number">12.1. </span>Parsen der Anfrage<a class="headerlink" href="#parsen-der-anfrage" title="Permalink to this headline">#</a></h2>
<p>Der erste Schritt im Ablauf einer Anfragebearbeitung ist das Parsen der Anfrage. Dazu wird zunächst eine Syntaxanalyse durchgeführt.</p>
<section id="syntaxanalyse">
<h3><span class="section-number">12.1.1. </span>Syntaxanalyse<a class="headerlink" href="#syntaxanalyse" title="Permalink to this headline">#</a></h3>
<p>Die Aufgabe einer Syntaxanalyse ist die Umwandlung einer SQL Anfrage in einen Parsebaum.<br>
In einem Parsebaum werden folgende Elemente als Atome (Blätter) dargestellt:</p>
<ul class="simple">
<li><p>Schlüsselworte</p></li>
<li><p>Konstanten</p></li>
<li><p>Namen (Relationen und Attribute)</p></li>
<li><p>Syntaxzeichen</p></li>
<li><p>Operatoren</p></li>
</ul>
<p>Bei Syntaktischen Kategorien können Teilausdrücke einer Anfrage Namen gegeben werden. Die Teilausdrücke können also zu Kategorien zusammengefasst werden, beispielsweise bei einer VIEW.<br />
<br></p>
</section>
<section id="eine-grammatik-fur-einen-teil-von-sql">
<h3><span class="section-number">12.1.2. </span>Eine Grammatik für einen Teil von SQL<a class="headerlink" href="#eine-grammatik-fur-einen-teil-von-sql" title="Permalink to this headline">#</a></h3>
<p>Die Anfragen unterliegen einer Grammatik (wie man sie aus der theoretischen Informatik kennt). Sie bestehen aus einer Struktur der Form “SELECT FROM WHERE”, kurz SFW. Es können keine Anfragen formuliert werden, die nicht der Grammatik entsprechen.<br></p>
<ul>
<li><p>Anfragen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  - &lt;Anfrage&gt; :: = &lt;SFW&gt;
  - &lt;Anfrage&gt; :: = (&lt;SFW&gt;)
  - Mengenoperatoren fehlen
</pre></div>
</div>
</li>
<li><p>SFWs:<br>
Die SFWs werden wie folgt aufgebaut, es fehlen Gruppierungen, Sortierungen etc.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  - &lt;SFW&gt; ::= SELECT &lt;SelListe&gt; FROM &lt;FromListe&gt; WHERE &lt;Bedingung&gt;
</pre></div>
</div>
</li>
<li><p>Listen:<br>
Dabei ergibt sich eine SelListe(SelectListe) aus einem Attribut und einer anderen SelListe bzw. nur aus einem Attribut.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  - &lt;SelListe&gt; ::= &lt;Attribut&gt;, &lt;SelListe&gt;
  - &lt;SelListe&gt; ::= &lt;Attribut&gt;
</pre></div>
</div>
<p>Die FromListe ergibt sich aus einer Relation oder aus einer Relation mit einer weiteren FromListe.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  - &lt;FromListe&gt; ::= &lt;Relation&gt;, &lt;FromListe&gt;
  - &lt;FromListe&gt; ::= &lt;Relation&gt;
</pre></div>
</div>
</li>
<li><p>Bedingungen (Beispiele):<br>
Bedingungen können Verknüpfungen bzw. Kombinationen von anderen Bedingungen sein. Verknüpft werden können sie beispielsweise mit AND oder auch mit OR:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  - &lt;Bedingung&gt; ::= &lt;Bedingung&gt; AND &lt;Bedingung&gt;
</pre></div>
</div>
<p>Eine Bedingung kann auch eine Anfrage sein, bei der eine Überprüfung in einer anderen Anfrage angefordert wird:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  - &lt;Bedingung&gt; ::= &lt;Tupel&gt; IN &lt;Anfrage&gt;
  - &lt;Bedingung&gt; ::= &lt;Attribut&gt; = &lt;Attribut&gt;
  - &lt;Bedingung&gt; ::= &lt;Attribut&gt; LIKE &lt;Muster&gt;
</pre></div>
</div>
</li>
<li><p>Tupel, Attribute, Relationen und Muster:<br>
Die Inhalte von Tupeln, Attributen, Relationen und Mustern sind nicht durch grammatische Regeln definiert. Entweder sie existieren oder sie existieren nicht. <br>
Angenommen man wählt eine Relation aus, die nicht existiert. Die Anfrage kann nicht korrekt ausgeführt werden und die Datenbank gibt zurück, dass es diese Relation nicht gibt.
<br><br>
Die vollständige Grammatik kann man z.B. unter <a class="reference external" href="http://docs.openlinksw.com/virtuoso/GRAMMAR.html">http://docs.openlinksw.com/virtuoso/GRAMMAR.html</a> finden.</p></li>
</ul>
</section>
<section id="parse-baum">
<h3><span class="section-number">12.1.3. </span>Parse-Baum<a class="headerlink" href="#parse-baum" title="Permalink to this headline">#</a></h3>
<p><img alt="" src="../_images/parsebaum.jpg" /></p>
<p>In diesem Bild ist der Aufbau eines Parsebaums dargestellt, der anhand der vorherigen SQL-Anfrage erstellt wurde. Dabei besteht die Anfrage aus einem SFW. Das SFW kann wiederrum unterteilt werden in SELECT, SelListe, … <br>
Alle Konstanten und Relationen lassen sich in den Blattstrukturen wiederfinden.</p>
</section>
<section id="prufung-der-semantik">
<h3><span class="section-number">12.1.4. </span>Prüfung der Semantik<a class="headerlink" href="#prufung-der-semantik" title="Permalink to this headline">#</a></h3>
<p>Die Prüfung der Semantik auf Korrektheit erfolgt während der Übersetzung. Dabei werden auf verschiedene Punkte geachtet, unter Anderem:</p>
<ul class="simple">
<li><p>Existieren die Relationen und Sichten der FROM Klausel?</p></li>
<li><p>Existieren die Attribute in den genannten Relationen?</p></li>
<li><p>Sind sie eindeutig?</p></li>
<li><p>Sind korrekte Typen für Vergleiche gegeben? (Bsp.: Vergleicht man einen Integer mit einem String)</p></li>
<li><p>Aggregation korrekt?</p></li>
<li><p>…</p></li>
</ul>
</section>
<section id="vom-parse-baum-zum-operatorbaum">
<h3><span class="section-number">12.1.5. </span>Vom Parse-Baum zum Operatorbaum<a class="headerlink" href="#vom-parse-baum-zum-operatorbaum" title="Permalink to this headline">#</a></h3>
<p><img alt="" src="../_images/operatorbaum.jpg" /></p>
<p>Der vorherige Schritt hat einen Parsebaum generiert. Dieser wird jetzt in einen Operatorbaum umgewandelt. Dargestellt werden kann der Operatorbaum mittels Relationaler Algebra. Dabei entspricht das SELECT einer Projektion und das WHERE einer Selektion. Aus den Schlüsselwörtern werden konkrete Operatoren. Es ist nun auch bekannt, dass spielt_in und Schauspieler durch ein Kreuzprodukt kombiniert werden. Diese beiden Relationen sind also der Input des Kreuzprodukts. Auf dem Output des Kreuzproduktes findet dananch eine Selektion statt und auf dessen Output letztendlich eine Projektion.</p>
</section>
</section>
<section id="transformationsregeln-der-ra">
<h2><span class="section-number">12.2. </span>Transformationsregeln der RA<a class="headerlink" href="#transformationsregeln-der-ra" title="Permalink to this headline">#</a></h2>
<p>Für jede Anfrage gibt es verschiedene Pläne. Das bedeutet also auch, dass es verschiedene Operatorenbäume gibt. Somit kann man  verschiedene Anfragen ineinander transformieren. Dies wird anhand der Transformationseregeln der Relationalen Algebra dargestellt.</p>
<section id="anfragebearbeitung-transformationsregeln">
<h3><span class="section-number">12.2.1. </span>Anfragebearbeitung – Transformationsregeln<a class="headerlink" href="#anfragebearbeitung-transformationsregeln" title="Permalink to this headline">#</a></h3>
<p>Die Transformation der internen Darstellung soll ohne eine Änderung der Semantik erfolgen. Damit ist gemeint, dass die Operatorenbäume nach der Transformation immernoch die gleiche Anfrage wie vor der Transformation beantworten können bzw. es kommt immernoch das gleiche Ergebnis heraus.<br>
Das Ziel einer Transformation ist es eine effizientere Ausführung zu finden. Die Operatoren sollen möglichst kleine Zwischenergebnisse liefern. Der nächste Operator soll als Input möglichst kleine Mengen von Tupeln erhalten, auf denen er arbeiten kann.
<br><br>
Um diese Transformation zu vollführen, müssen zunächst äquivalente Ausdrücke identifiziert werden.
Zwei Ausdrücke der relationalen Algebra gelten als äquivalent, falls sie gleiche Operanden (= Relationen) besitzen und stets die gleiche Antwortrelation zurückgeben.
‘Stets’ bedeutet hierbei, dass nicht per Zufall die gleichen Ergebnisse bei mehreren Anfragen herauskommen. Für jede mögliche Instanz der Datenbank, muss jedes Mal das gleiche Ergebnis entstehen.
<br></p>
</section>
<section id="anfragebearbeitung-beispiel">
<h3><span class="section-number">12.2.2. </span>Anfragebearbeitung – Beispiel<a class="headerlink" href="#anfragebearbeitung-beispiel" title="Permalink to this headline">#</a></h3>
<p>In diesem Beispiel soll der Nachname projiziert werden. Dafür wird das Kreuzprodukt zwischen den Relationen ‘Mitarbeiter’ und ‘Projekte’ erstellt. Darauf werden alle Paare, bei denen die Mitarbeiter-ID gleich der Projekt-ID ist, selektiert. Die Projekte, die ein gleiches oder größeres Budget als 40000 haben, werden aussortiert.</p>
<p><img alt="" src="../_images/anfragebearbeitung_bsp1.jpg" /></p>
<p>Es kann nun überlegt werden, wo man noch früher Tupel herausfiltern kann. Eine Möglichkeit wäre es die Selektion mit dem Kreuzprodukt zu einem Join zu kombinieren.
Eine Andere wäre es, die übrig gebliebene Selektion früher durchzuführen. Noch bevor das Kreuzprodukt der beiden Relationen gebildet wird, kann man die Selektion ‘p.Budget &lt; 40000’ auf der ‘projekt’-Relation ausführen. Die Erwartung ist, dass der nachfolgende Join auf einer kleineren Tupelmenge ausgeführt wird.</p>
<p><img alt="" src="../_images/anfragebearbeitung_bsp2.jpg" /></p>
</section>
<section id="kommutativitat-und-assoziativitat">
<h3><span class="section-number">12.2.3. </span>Kommutativität und Assoziativität<a class="headerlink" href="#kommutativitat-und-assoziativitat" title="Permalink to this headline">#</a></h3>
<p>Die Kommutativität und Assoziativität gelten insbesondere für Mengenoperationen. <br></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\cup\)</span> ist kommutativ und assoziativ
<br>
R <span class="math notranslate nohighlight">\(\cup\)</span> S = S <span class="math notranslate nohighlight">\(\cup\)</span> R
<br>
(R <span class="math notranslate nohighlight">\(\cup\)</span> S) <span class="math notranslate nohighlight">\(\cup\)</span> T = R <span class="math notranslate nohighlight">\(\cup\)</span> (S <span class="math notranslate nohighlight">\(\cup\)</span> T)
<br><br></p></li>
<li><p><span class="math notranslate nohighlight">\(\cap\)</span> ist kommutativ und assoziativ
<br>
R <span class="math notranslate nohighlight">\(\cap\)</span> S = S <span class="math notranslate nohighlight">\(\cap\)</span> R
<br>
(R <span class="math notranslate nohighlight">\(\cap\)</span> S) <span class="math notranslate nohighlight">\(\cap\)</span> T = R <span class="math notranslate nohighlight">\(\cap\)</span> (S <span class="math notranslate nohighlight">\(\cap\)</span> T)
<br><br></p></li>
<li><p>⋈ ist kommutativ und assoziativ
<br>
R ⋈ S = S ⋈ R
<br>
(R ⋈ S) ⋈ T = R ⋈ (S ⋈ T)</p>
<p><br>Bei einem Join kann es passieren, dass die Spaltenreihenfolge anders ist. Sie kann nachträglich noch geändert werden (bspw. mit einer Projektion).</p>
</li>
</ul>
<p>Alle diese Regeln gelten jeweils für Mengen und für Multimengen. Zudem können die Ausdrücke in beide Richtungen verwendet werden.</p>
</section>
<section id="weitere-regeln">
<h3><span class="section-number">12.2.4. </span>Weitere Regeln<a class="headerlink" href="#weitere-regeln" title="Permalink to this headline">#</a></h3>
<ul>
<li><p>Selektion<br></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\sigma_{c1 AND c2}(R ) = \sigma_{c1}(\sigma_{c2} (R))\)</span></p>
<p>Wenn es eine Selektion mit zwei Bedingungen ist, kann sie in zwei Selektionen, die aufeinander aufbauen, kaskadiert werden.</p>
</li>
<li><p><span class="math notranslate nohighlight">\(\sigma_{c1 OR c2}(R ) = \sigma_{c1}(R) \cup \sigma_{c2} (R)\)</span></p>
<p>Wenn es eine Selektion mit einem OR ist, kann davon die Vereinigung gebildet werden.
<br>Dabei kommt es zu einem Problem bei Multimengen:<br>
c1 or c2 bedeutet, gebe jedes Tupel zurück, egal ob Bedingung c1, c2 oder beide gelten. Man würde bei der Vereinigung eine andere Anzahl an Tupeln bekommen. Bei den Fällen bei denen beide Bedingungen gelten, würde es das Tupel doppelt geben.</p>
</li>
<li><p><span class="math notranslate nohighlight">\(\sigma_{c1}(\sigma_{c2}(R)) = \sigma_{c2}(\sigma_{c1}(R))\)</span></p>
<p>Die äußere Bedigung kann mit der inneren Bedingung vertauscht werden. Dabei sollte die günstigere Bedingung am besten zuerst ausgeführt werden.</p>
</li>
<li><p><span class="math notranslate nohighlight">\(\sigma_{c}(R \Phi S) \equiv (\sigma_{c} (R)) \Phi (\sigma_{c} (S))\)</span></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Phi \in \{\cup, \cap , - , ⋈\}\)</span></p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(\sigma_{c}(R \Phi S) \equiv (\sigma_{c} (R)) \Phi S\)</span></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Phi \in \{\cup, \cap , - , ⋈\}\)</span></p></li>
<li><p>Falls sich c nur auf Attribute in R bezieht, kann es so umgeformt werden, sodass sich die Selektion nur auf die Relation R bezieht.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Projektion <br></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\pi_{L}(R ⋈ S) = \pi_{L}(\pi_{M}(R) ⋈ \pi_{N}(S))\)</span><br>
Eine Projektion einer Spalte auf einem Join zweier Relationen kann einer Projektion einer Spalte auf einem Join zweier Projektionen auf jeweils einer Relation entsprechen.</p></li>
<li><p><span class="math notranslate nohighlight">\(\pi_{L}(R ⋈_{C} S) = \pi{L}(\pi_{M}(R) ⋈_{C} \pi_{N}(S))\)</span><br>
Genauso kann nun auch bei einem Join mit Bedingung und einem Kreuzprodukt vorgegangen werden.</p></li>
<li><p><span class="math notranslate nohighlight">\(\pi_{L}(R \times S) = \pi_{L}(\pi_{M}(R) \times \pi_{N}(S))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\pi_{L}(\sigma_{C}(R)) = \pi_{L}(\sigma_{C}(\pi_{M}(R)))\)</span><br>
Hierbei kann eine Projektion noch vor die Selektion geschoben werden. Wichtig dabei ist, dass die neue Projektion (<span class="math notranslate nohighlight">\(\pi_{M}\)</span>) L enthält. Es können auch weitere Projektionen hinzugefügt werden. Solange sie L enthalten, verändert sich nichts.</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="optimierung">
<h2><span class="section-number">12.3. </span>Optimierung<a class="headerlink" href="#optimierung" title="Permalink to this headline">#</a></h2>
<p>Weitere Optimierungen haben das Ziel die Anfragen von zuvor noch schneller bearbeiten zu können.</p>
<section id="anfragebearbeitung-optimierung">
<h3><span class="section-number">12.3.1. </span>Anfragebearbeitung - Optimierung<a class="headerlink" href="#anfragebearbeitung-optimierung" title="Permalink to this headline">#</a></h3>
<p>Bei der Anfragebearbearbeitung wird eine regelbasierte Optimierung durchgeführt. Dabei schreibt ein fester Regelsatz Transformationen vor. Die Transformationen sollen eine Anfrage schneller bearbeiten. <br>
Die Prioritäten unter den Regeln werden durch Heuristiken bestimmt. Es ist nach Erfahrung der beste Weg, es muss aber nicht immer der Fall sein. Ein Beispiel einer solchen Optimierung ist das ‘pushen’ einer Selektion nach unten im Anfragebaum.
<br><br>
Außerdem wird noch eine kostenbasierte Optimierung angewandt. Für jede Relation kann ein Kostenmodell aufgestellt werden. Das Kostenmodell basiert dabei auf Statistiken, die das Datenbankmodell gesammelt hat. Nach dem Aufstellen des Kostenmodells kann mit diesem ein optimaler Plan bestimmt werden, bei dem die Kosten minimal sind. Dazu kann auch die optimale Joinreihenfolge bestimmt werden. Transformationen helfen hierbei die Kosten zu verringern.
<br><br>
Im Allgemeinen wird nicht die optimale Auswertungsstrategie gesucht, sondern eine einigermaßen effiziente Variante. Sie soll  dabei helfen den schlimmsten Fall zu verhindern -&gt; Avoid the worst case!</p>
</section>
<section id="logische-optimierung">
<h3><span class="section-number">12.3.2. </span>Logische Optimierung<a class="headerlink" href="#logische-optimierung" title="Permalink to this headline">#</a></h3>
<p>Bei der logischen Optimierung kann anhand der Transformationsregeln jeder Ausdruck im Anfragebaum in viele verschiedene, semantisch äquivalente Ausdrücke umgeschrieben werden. Dabei wird der (hoffentlich) beste Ausdruck (=Plan, =QEP (QueryExecutionPlan)) ausgewählt.</p>
</section>
<section id="physische-optimierung">
<h3><span class="section-number">12.3.3. </span>Physische Optimierung<a class="headerlink" href="#physische-optimierung" title="Permalink to this headline">#</a></h3>
<p>Für jede relationale Operation gibt es viele verschiedene Implementierungen:
Zum Beispiel für den Zugriff auf Tabellen kann es ein Scan, verschiedene Indizes, ein sortierter Zugriff, etc. sein.
Genauso bei Joins können auch verschiedene Implementierungen wie Nested loop, sort-merge, hash, etc. ausgewählt werden.
Für jede Operation wird wieder die (hoffentlich) beste Implementierung ausgewählt.
<br><br>
Es kann nun sein, dass die logische von der physischen Optimierung abhängt.
Beispielsweise kann es sein, dass ein bestimmter Plan besser funktioniert, wenn man einen Nested-Loop-Join durchführt. Wenn eine Schleife innerhalb einer anderen ist, kann in der einen Schleifen bereits etwas Anderes mitgeprüft werden. Das würde einem bestimmten logischen Plan besser entsprechen.</p>
</section>
<section id="logische-optimierung-regelbasiert">
<h3><span class="section-number">12.3.4. </span>Logische Optimierung – regelbasiert<a class="headerlink" href="#logische-optimierung-regelbasiert" title="Permalink to this headline">#</a></h3>
<p>Die Grundsätze der logischen Optimierung lauten wie folgt:</p>
<ul class="simple">
<li><p>Selektionen sollen so weit wie möglich im Baum nach unten geschoben werden.</p></li>
<li><p>Selektionen mit AND können aufgeteilt und separat verschoben werden.</p></li>
<li><p>Projektionen sollen so weit wie möglich im Baum nach unten geschoben werden,</p></li>
<li><p>bzw. neue Projektionen können eingefügt werden.
<br>Bei dem nach unten Verschieben von Selektionen und Projektionen gibt es einen Unterschied: <br>Bei dem Verschieben von Selektionen geht es darum die Menge an Tupeln zu verringern. Bei Projektionen wird versucht die Anzahl der Spalten zu verringern. <br>
Beides ist sinnvoll, da bei riesigen Datensätzen eine Spalte mehrere Gigabyte groß sein kann. Wenn solche Spalten nicht unbedingt mehr mitgeschleppt werden müssen, wird das Programm effizienter.</p></li>
<li><p>Duplikateliminierung kann manchmal entfernt oder verschoben werden.</p></li>
<li><p>Kreuzprodukte sollen mit geeigneten Selektionen zu einem Join zusammengefasst werden. Generell sollen Kreuzprodukte möglichst vermieden werden, stattdessen können Joins mit effizienteren Implementierungen durchgeführt werden.</p></li>
</ul>
<p>In dieser Vorlesung geht es nicht um die Suche nach der optimalen Joinreihenfolge. Diese Thematik wird erst in aufbauenden Veranstaltungen genauer betrachtet.</p>
</section>
<section id="anwendung-der-transformationsregeln">
<h3><span class="section-number">12.3.5. </span>Anwendung der Transformationsregeln<a class="headerlink" href="#anwendung-der-transformationsregeln" title="Permalink to this headline">#</a></h3>
<p>Die folgende Anfrage ist von Prof. Alfons Kemper (TU München).
Bei der Anfrage werden eindeutig alle Semester gesucht, in denen für Studenten, hören, Vorlesungen und Professoren folgende Bedingungen gelten:
Der Professor heißt mit Namen ‘Sokrates’. Dieser Professor soll Vorlesungen halten und die Vorlesungen sollen von Studierenden gehört werden.
Es soll also in Erfahrung gebracht werden: In welchen Semestern sind die Studierenden, die Vorlesungen bei Sokrates hören?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>select distinct s.Semester
from Studiernden s, hören h
Vorlesungen v,
Professorinnen p
where p.Name = ´Sokrates´
and v.gelesenVon = p.PersNr
and v.VorlNr = h.VorlNr
and h.MatrNr = s.MatrNr
</pre></div>
</div>
<p>Zunächst ist eine Darstellung gegeben, bei der es ein Kreuzprodukt aller Relationen gibt. Dann kommen die aneinandergereihten Selektionsoperatoren. Es ist nicht die logisch effizienteste Variante.</p>
<p><img alt="" src="../_images/transformationsregeln.jpg" /></p>
</section>
<section id="aufspalten-der-selektionspradikate">
<h3><span class="section-number">12.3.6. </span>Aufspalten der Selektionsprädikate<a class="headerlink" href="#aufspalten-der-selektionspradikate" title="Permalink to this headline">#</a></h3>
<p>Als erstes wird die Selektion aufgespalten und in einzelne Operationen zerteilt. Im nächsten Schritt wird sich eine effizientere Platzierung der Selektionen überlegt.</p>
<p><img alt="" src="../_images/aufspalten_selektionspraedikate.jpg" /></p>
</section>
<section id="verschieben-der-selektionspradikate-pushing-selections">
<h3><span class="section-number">12.3.7. </span>Verschieben der Selektionsprädikate „Pushing Selections“<a class="headerlink" href="#verschieben-der-selektionspradikate-pushing-selections" title="Permalink to this headline">#</a></h3>
<p>Um die Anzahl der Tupel zu verringern, werden die Selektionen weiter nach unten geschoben.
Das ist der Fall bei den Studierenden, die eine Vorlesung hören. Um deren Anzahl zu verringern, wird nach dem Kreuzprodukt zwischen den beiden Relationen ‘studierende’ und ‘hören’ die Selektion platziert.
Die kleinere Menge an Tupeln als Output wird dann wie zuvor über das Kreuzprodukt mit ‘Vorlesungen’ kombiniert. Mit einer Selektion wird die Anzahl der Tupel reduziert, bevor ein weiteres Kreuzprodukt gebildet wird.
Ansonsten ist direkt vor die Professorentabelle die Selektion mit der Bedingung, dass der Name des Professors Sokrates sein soll, geschoben worden. Somit ist der Ouptut nach der Selektion nur ein Tupel und es müssen nicht mehr alle Professorentupel mitgeführt werden.</p>
<p><img alt="" src="../_images/verschieben_selektionspraedikate.jpg" /></p>
</section>
<section id="zusammenfassung-von-selektionen-und-kreuzprodukten-zu-joins">
<h3><span class="section-number">12.3.8. </span>Zusammenfassung von Selektionen und Kreuzprodukten zu Joins<a class="headerlink" href="#zusammenfassung-von-selektionen-und-kreuzprodukten-zu-joins" title="Permalink to this headline">#</a></h3>
<p>Die Selektionen werden mit den Kreuzprodukten zusammengefasst und durch effizienter implementierte Joins ausgetauscht.</p>
<p><img alt="" src="../_images/zusammenfassen_selektionspraedikate.jpg" /></p>
</section>
<section id="optimierung-der-joinreihenfolge-kommutativitat-und-assoziativitat-ausnutzen">
<h3><span class="section-number">12.3.9. </span>Optimierung der Joinreihenfolge: Kommutativität und Assoziativität ausnutzen<a class="headerlink" href="#optimierung-der-joinreihenfolge-kommutativitat-und-assoziativitat-ausnutzen" title="Permalink to this headline">#</a></h3>
<p>Die Kommutativität und Assoziativität werden jetzt ausgenutzt, um die Joinreihenfolge zu optimieren. Die Tupelmenge wird möglichst gering gehalten.
Daher wird die Selektion des Professorennames nach ganz unten verschoben. Grund hierfür ist, dass aus dieser Selektion nur ein Tupel herauskommt, mit dem man weiterarbeiten muss. Danach vergrößert sich die Tupelmenge nur minimal um die Vorlesungen, die der Professor hält, usw.
Ohne diese Optimierung wird mit der gesamten Menge an Studierenden, die diese Vorlesung hören, gestartet. Diese große Tupelmenge muss als Input für die nächsten Operationen mitgenommen werden, was vermeidbare Kosten verursacht.</p>
<p><img alt="" src="../_images/joinreihenfolge1.jpg" /></p>
</section>
<section id="was-hat-s-gebracht">
<h3><span class="section-number">12.3.10. </span>Was hat´s gebracht?<a class="headerlink" href="#was-hat-s-gebracht" title="Permalink to this headline">#</a></h3>
<p>Ohne die Optimierungen sind das Maximum 13 Tupel mit denen gearbeitet werden muss. Generell wird hier immer mit einer sehr hohen Anzahl von Tupeln gearbeitet, im Gegensatz zu der Variante mit Optimierungen. Durch die Optimierungen wird nur auf maximal 4 Tupeln gearbeitet.</p>
<p>Es handelt sich hier um ein ausgedachtes Beispiel. Die Zahlen sind nicht logisch herleitbar. Es soll nur darstellen, wie sich das Verschieben von günstigen Join-Varianten auf die Tupelmenge, verhält.</p>
<p><img alt="" src="../_images/joinreihenfolge2.jpg" /></p>
</section>
<section id="einfugen-von-projektionen">
<h3><span class="section-number">12.3.11. </span>Einfügen von Projektionen<a class="headerlink" href="#einfugen-von-projektionen" title="Permalink to this headline">#</a></h3>
<p>Nun können noch Projektionen einfügt werden, wenn bestimmte Spalten nicht mehr benötigt werden. Das wäre bei der Matrikelnummer der Fall, denn es wird im Nachhinein nur noch die Matrikelnummer aus den Attributen beim Join und der Projektion danach benötigt. Insbesondere wird dort ein Left-Join ausgeführt.</p>
<p><img alt="" src="../_images/einfuegen_projektion.jpg" /></p>
</section>
<section id="sqlite-explain">
<h3><span class="section-number">12.3.12. </span>SQLite Explain<a class="headerlink" href="#sqlite-explain" title="Permalink to this headline">#</a></h3>
<p>Anfragepläne können auch in SQLite ausprobiert werden. Dafür muss vor der Anfrage mit ‘.eqp on’ eingegeben werden. Für jede Anfrage wird jetzt der Plan direkt gezeigt.
Es kann auch explizit mit ‘EXPLAIN QUERY PLAN’ eingestellt werden. Danach wird wie gewohnt die SQL-Anfrage eingegeben.
Nun kann die tatsächliche Implementierung angesehen werden. Zunächst wird die ‘producer’ Tabelle gescannt. Dann wird ein Autoindex für ‘movie’ verwendet, weil der Primärschlüssel ‘mid’ verwendet wird. Dieser Index wird für den IN-OPERATOR verwendet und es wird ein B-TREE verwendet, um die doppelten Werte zu vermeiden.</p>
<p><img alt="" src="../_images/sqlite.jpg" /></p>
</section>
</section>
<section id="kostenmodelle">
<h2><span class="section-number">12.4. </span>Kostenmodelle<a class="headerlink" href="#kostenmodelle" title="Permalink to this headline">#</a></h2>
<p>Mittels Kostenmodellen sollen Anfrageausführungspläne verglichen und anhand ihrer Kosten bewertet werden, um letztendlich den besten Anfrageausführungsplan auszuwählen.</p>
<section id="kostenbasierte-optimierung">
<h3><span class="section-number">12.4.1. </span>Kostenbasierte Optimierung<a class="headerlink" href="#kostenbasierte-optimierung" title="Permalink to this headline">#</a></h3>
<p>Generell müssen konzeptionell alle denkbaren Anfrageausführungspläne generiert werden, um den besten darunter auszuwählen. Dabei werden die Kosten der Pläne anhand eines Kostenmodells bewertet. Hierzu werden Statistiken und Histogramme zur Hilfe genommen.
Die Statistiken können vom verfügbaren Speicher oder vom System abhängig sein. Je nach verwendetem Rechner, kann eine Operation eventuell unterschiedlich viel Zeit benötigen. Daher benötigt es eine Kalibrierung gemäß dem verwendetn Rechner.
Beim Aufwands-Kostenmodell wird meistens probiert den Durchsatz zu maximieren und nicht die Antwortzeit zu minimieren.
<br>
Da es hierbei um Kosten geht, soll der billigste Plan ausgeführt werden. Dennoch sollte darauf geachtet werden nicht zu lange zu optimieren, denn das Optimieren selbst kostet auch wieder Zeit und macht die Anfrage langsamer. Irgendwie muss ein Zwischenweg zwischen beidem gefunden werdenn. Dies kann beispielsweise mithilfe von Heuristiken geschehen.</p>
</section>
<section id="problemgrosze-suchraum">
<h3><span class="section-number">12.4.2. </span>Problemgröße (Suchraum)<a class="headerlink" href="#problemgrosze-suchraum" title="Permalink to this headline">#</a></h3>
<p>Wenn alle denkbaren Anfrageausführungspläne konzeptionell generiert wurden, wird die Anzahl der Bushy-Pläne bei n Tabellen gemäß der folgenden Formel berechnet:</p>
<p><span class="math notranslate nohighlight">\(\frac{(2(n-1))!}{(n-1)!}\)</span></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>n</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(2^n\)</span></p></th>
<th class="head"><p>(2(n-1))!/(n-1)!</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>32</p></td>
<td><p>1680</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>1024</p></td>
<td><p>1,76 <span class="math notranslate nohighlight">\(\times 10^{10}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>20</p></td>
<td><p>1.048.576</p></td>
<td><p><span class="math notranslate nohighlight">\(4,3\times10^{27}\)</span></p></td>
</tr>
</tbody>
</table>
<p>Bei wachsender Anzahl von n Tabellen, wächst der Suchraum sehr stark an. Die Plankosten unterscheiden sich somit schnell um viele Größenordnungen.
Das Optimierungsproblem, unabhängig von den Bushy-Plänen, ist NP-hart.</p>
</section>
<section id="kostenmodell">
<h3><span class="section-number">12.4.3. </span>Kostenmodell<a class="headerlink" href="#kostenmodell" title="Permalink to this headline">#</a></h3>
<p><img alt="" src="../_images/kostenmodell.jpg" /></p>
<p>Es ist ein algebraischer Ausdruck gegeben. Dieser wird einem Kostenmodell übergeben und daraus ergeben sich die Ausführungskosten ohne den Ausdruck ausgeführt zu haben.
Das Kostenmodell betrachtet dabei Indexinformationen, Ballungs-Informationen (Clustering on disk), DB-Kardinalitäten und Attributverteilungen.</p>
</section>
<section id="statistiken">
<h3><span class="section-number">12.4.4. </span>Statistiken<a class="headerlink" href="#statistiken" title="Permalink to this headline">#</a></h3>
<p>Durch Statistiken können verschiedene Informationen zu den Elementen erhalten werden. <br>
Bei einer Basisrelation wäre es die Anzahl der Tupel und deren Tupelgröße. <br><br />
Bei (jedem) Attribut ist der größte und kleinste Wert bekannt.
Es kann auch ein Histogramm zur Werteverteilung geben und die Anzahl der ‘distinct’-Werte (Kardinalität) ist bekannt. <br>
Zum System sind die Speichergröße, die Bandbreite, die I/O-, sowie die CPU-Zeiten gegeben. <br>
<br>
Problem: Die Statistiken gelten nur für einen Zustand der Datensätze. Theoretisch muss nach jeder Veränderung der Datenbank neue Statistiken erstellt oder die bestehenden Statistiken geupdatet werden. Das verursacht hohe Kosten und wird daher meistens nur nach einer bestimmten Zeit manuell/explizit durchgeführt mit einer Funktion wie runstats().
<br><br></p>
<p><img alt="" src="../_images/statistik.jpg" /></p>
</section>
<section id="kosten-von-operationen">
<h3><span class="section-number">12.4.5. </span>Kosten von Operationen<a class="headerlink" href="#kosten-von-operationen" title="Permalink to this headline">#</a></h3>
<p>Es gibt bestimmte Kosten für Operationen, die unabhängig vom Kostenmodell gelten:</p>
<ul class="simple">
<li><p>Projektion:</p>
<ul>
<li><p>Wenn eine Projektion mit einem anderem Operator kombiniert wird, dann kostet diese nichts.</p></li>
</ul>
</li>
<li><p>Selektion:</p>
<ul>
<li><p>Bei einer Seletktion ohne Index wird die gesamte Relation von der Festplatte gelesen. Die gesamte Relation ist daher Teil der Kosten.</p></li>
<li><p>Bei einer Selektion mit Baum-Index (z.B. B-Baum) muss man einen Teil des Index (Baumtiefe) und die gesuchte Seite von der Festplatte lesen.</p></li>
<li><p>Beim Pipelining hat man (fast) keine Kosten. Wenn die Selektion immer wieder an eine Datenpipeline herangehangen wird, verursacht es (fast) keine Kosten.</p></li>
</ul>
</li>
<li><p>Join:</p>
<ul>
<li><p>Beim Join hängen die Kosten vom Joinalgorithmus (Nested Loops, Hash-Join, Sort-Merge Join, usw.) ab.</p></li>
</ul>
</li>
<li><p>Sortierung:</p>
<ul>
<li><p>Die Kosten von Sortierungen werden in einer aufbauenden Veranstaltung besprochen. Es wird sich dabei um Sortieralgorithmen wie Two-Phase-Merge-Sort handeln.</p></li>
</ul>
</li>
</ul>
<p>Generell sind die Kosten von Operationen die Anzahl der Tupel im Input. Dabei fragt man sich, ob die Relation in den Hauptspeicher passt. Je kleiner die Anzahl der Tupel im Input ist, desto wahrscheinlicher passt sie in den Hauptspeicher. <br>
Bedacht werden muss auch, wie groß die Anzahl der Tupel im Output einer Operation ist. Der Output wird nämlich der Input des nächsten Operators sein. Aus diesem Grund schätzt ein Kostenmodel unter anderem für jede Operation die Anzahl der Ausgabetupel.
Das Schätzen der Ausgabetupel geschieht also unter Betrachtung des Selektivitätsfaktors (selectivity factor, sf). Dieser Faktor beschreibt die „Selektivität“ in Bezug auf die Inputgröße.</p>
<ul class="simple">
<li><p>#Ausgabetupel = #Eingabetupel x Selektivität</p></li>
</ul>
<p>Beispiel: Eine Operation mit Selektivitätsfaktor 0.5 wird auf eine Relation angewandt (O( R)). Dann ist die Anzahl der Ausgabetupel wahrscheinlich |R| / 2.</p>
</section>
<section id="selektivitat">
<h3><span class="section-number">12.4.6. </span>Selektivität<a class="headerlink" href="#selektivitat" title="Permalink to this headline">#</a></h3>
<p>Die Selektivität schätzt die Anzahl der qualifizierenden Tupel relativ zur Gesamtanzahl der Tupel in der Input Relation.
<br></p>
<p>Bei Projektionen ist die Selektivität genau 1. Die Operation erhält R Tupel als Input und gibt R viele Tupel als Output wieder heraus.</p>
<ul class="simple">
<li><p>sf = |R|/|R| = 1</p></li>
</ul>
<br>
Bei der Selektion ist der Selektivitätsfaktor die Anzahl der Tupel der selektierten Menge geteilt durch die gesamte Anzahl der Tupel.
<ul class="simple">
<li><p>sf = |<span class="math notranslate nohighlight">\(\sigma_c\)</span>( R)| / |R|</p></li>
</ul>
<br>
Bei Joins ergibt sich der Selektivitätsfaktor aus der Selektivität des Joins geteilt durch die Selektivität des Kreuzproduktes. Das Kreuzprodukt ergibt sich aus der Anzahl der Tupel einer Relation multipliziert mit der Anzahl der Tupel einer anderen Relation.  
<ul class="simple">
<li><p>sf = |R ⋈ S| / |R x S| = |R ⋈ S| / (|R| · |S|)</p></li>
</ul>
<section id="selektivitat-schatzen">
<h4><span class="section-number">12.4.6.1. </span>Selektivität schätzen<a class="headerlink" href="#selektivitat-schatzen" title="Permalink to this headline">#</a></h4>
<p>Selektion: <br>
Wenn eine Selektion auf einem einzelnen Schlüssel durchgeführt wird, also auf einer Konstanten, kann davon ausgegangen werden, dass der Selektivitätsfaktor genau</p>
<ul class="simple">
<li><p>sf = 1 / |R|</p></li>
</ul>
<p>ist, da ein Schlüssel immer nur einmal auftaucht.</p>
<p>Wenn aber eine Selektion auf einem Attribut A mit m verschiedenen Werten ausgeführt wird, ist der Selektivitätsfaktor:</p>
<ul class="simple">
<li><p>sf = (|R| / m) / |R| = 1/m</p></li>
</ul>
<p>Wird auf einer Spalte mit 10 unterschiedlichen Werten eine Selektion auf einem Wert ausgeführt, kann davon ausgegangen werden, dass im Schnitt 1/m Werte herauskommen. Dies ist nur eine Schätzung!</p>
<br>
Join: <br>
Beim Equijoin zwischen R und S über Fremdschlüssel in S ist der Selektivitätsfaktor:
<ul class="simple">
<li><p>sf = 1 / |R|</p></li>
<li><p>„Beweis“: sf = |R ⋈ S| / (|R x S|) = |S| / (|R| · |S|) <br>
Da man einen Equijoin über Fremdschlüssel durchführt, ist die Anzahl der Ausgabetupel gleich der Anzahl der Tupel in S. Somit kann man S aus |S| / (|R| · |S|) wegstreichen und es ergibt sich der Selektivitätsfaktor sf = 1 / |R|.</p></li>
</ul>
</section>
</section>
<section id="selinger-style-optimization">
<h3><span class="section-number">12.4.7. </span>Selinger-style“ Optimization<a class="headerlink" href="#selinger-style-optimization" title="Permalink to this headline">#</a></h3>
<p>Zum Vorherigen gibt es ein Paper aus den 70er Jahren von IBM. Im Folgenden ist die Darstellung vom Research Team zu sehen:</p>
<p><img alt="" src="../_images/selinger_style1.jpg" /></p>
<p><img alt="" src="../_images/selinger_style2.jpg" /></p>
</section>
<section id="join-selektivitat-selinger-style">
<h3><span class="section-number">12.4.8. </span>Join Selektivität (Selinger Style)<a class="headerlink" href="#join-selektivitat-selinger-style" title="Permalink to this headline">#</a></h3>
<p><img alt="" src="../_images/selinger_style3.jpg" /></p>
<p>Der Fokus liegt jetzt besonders auf der Join Selektivität. Dazu folgende Anfrage als Beispiel:</p>
<ul class="simple">
<li><p>SELECT * FROM cust, order WHERE <a class="reference external" href="http://cust.ID">cust.ID</a> = order.custID</p></li>
</ul>
<p>Die Kardinalität von customerID (<a class="reference external" href="http://cust.ID">cust.ID</a>) ist die Anzahl von customer (|cust|), weil es ein Schlüssel ist.</p>
<ul class="simple">
<li><p>DISTINCT <a class="reference external" href="http://cust.ID">cust.ID</a> = |cust|</p></li>
</ul>
<p>Die order-customer-ID (oder.custID) ist kleiner gleich der Anzahl der customer (cust), weil es weniger Bestellungen (orders) als Kunden (cust) sind.</p>
<ul class="simple">
<li><p>DISTINCT order.custID ≤ |cust|</p></li>
</ul>
<p>Dann muss nach der Formel aus dem Paper das Maximum der beiden Kardinalitäten genommen werden. Es ergibt sich ein Selektivitätsfaktor von:</p>
<ul class="simple">
<li><p>sf = 1/|cust|</p></li>
</ul>
<p>Der Join von customer (cust) und order gibt somit die gleiche Anzahl an Tupeln zurück wie die Anzahl an Tupeln in order.</p>
<ul class="simple">
<li><p>|cust ⋈ order| = 1/|cust| * |cust| * |order| = |order|</p></li>
</ul>
</section>
<section id="modelle-zum-besseren-schatzen-der-selektivitat">
<h3><span class="section-number">12.4.9. </span>Modelle zum besseren Schätzen der Selektivität<a class="headerlink" href="#modelle-zum-besseren-schatzen-der-selektivitat" title="Permalink to this headline">#</a></h3>
<p>Das Schätzen der Selektivität kann auf unterschiedliche Weisen verbessert werden. <br>
Eine Möglichkeit das Schätzen zu verbessern, wäre es eine Gleichverteilung der Werte anzunehmen, sodass die Minimum- und Maximumwerte bekannt sind. Bei einer ungleichen Verteilung (“skew”) ist die Abschätzung schwierig und eher schlecht. <br>
Dazu kann ein Histogramm zur Hilfe genommen werden. Parametrisierte Größen vereinfachen das Schätzen. Die Güte der Abschätzung hängt vom Histogrammtyp und der Histogrammgröße ab. Außerdem ist das Garantieren der Aktualität sehr aufwändig. <br>
Eine weitere Möglichkeit ist das Sampling. Dabei wird eine repräsentative Teilmenge der Relation angeschaut und schließt daraus auf die Verteilung der Werte. Parametrisierte Größen sind hierbei wieder schwierig zu finden. Die Güte hängt von der Samplingmethode und der Samplegröße ab. Außerdem ist die Aktualität auch wieder von Bedeutung.</p>
</section>
<section id="beispiel-zu-histogrammen">
<h3><span class="section-number">12.4.10. </span>Beispiel zu Histogrammen<a class="headerlink" href="#beispiel-zu-histogrammen" title="Permalink to this headline">#</a></h3>
<p><img alt="" src="../_images/histogramm.jpg" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="o">*</span>
<span class="n">FROM</span> <span class="n">product</span> <span class="n">p</span><span class="p">,</span> <span class="n">sales</span> <span class="n">S</span>
<span class="n">WHERE</span> <span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">p_id</span> <span class="ow">and</span>
<span class="n">p</span><span class="o">.</span><span class="n">price</span> <span class="o">&gt;</span> <span class="mi">100</span> 
</pre></div>
</div>
<p>Gegeben ist ein Histogramm mit 3300 Produkten und einer Preisspanne von 0 bis 1000. Zu jedem Bucket in der Preisspanne wird angegeben wie viele Produkte darin enthalten sind. Zudem ist eine ‘sales’ Relation mit einer Millionen Einträgen gegeben. <br>
<br>
Angenommen es findet eine Gleichverteilung statt. Dann ist der Preis gleichverteilt zwischen 0 und 1000. Aufgrund der Selektionsbedingung (p.price &gt; 100) wird nach allen Produkten, die mehr als 100 Kosten, gesucht. Es bleiben genau 900 Produkte übrig. Also kommen 900 von 1000 Einträgen weiter. Es ergibt sich eine Selektivität von 900/1000 = 9/10. Am Ende werden somit 9/10 * 3300 ≈ 3000 Produkte erwartet, die noch zusätzlich mit der sales Relation gejoint wird. <br>
<br>
Durch das Kennen des Aussehens des Histogramms, ist bekannt, dass es insgesamt nur 5 Produkte gibt, die über 100 kosten. Die Selektivität der Bedingung ist dann 5/3000 ≈ 0.0015. Somit deutlich geringer als zuvor.</p>
</section>
<section id="kosten-weitere-komplikationen">
<h3><span class="section-number">12.4.11. </span>Kosten – Weitere Komplikationen<a class="headerlink" href="#kosten-weitere-komplikationen" title="Permalink to this headline">#</a></h3>
<p>Es gibt weitere Komplikationen:<br>
Was passiert mit den Kosten, wenn bestimmte Operationen parallel ausgeführt werden? Die Kosten aller Operatoren können somit nicht addiert werden.<br>
Oder der Hauptspeicher bietet Möglichkeiten wie Pufferung und Caching. Damit können die Kosten für bestimmte Operatoren noch weiter verringert werden. <br>
Die I/O Kosten (Lesen einer Seite) könnten auch gegenüber den CPU Kosten einen ganz anderen Faktor spielen.<br>
Vielleicht gibt es mehrere Nutzer (Multiuser), die gleichzeitig arbeiten und es sollen so viele Nutzer wie möglich behandelt werden. Vielleicht soll auch die Antwortzeit der Nutzer verkleinert werden und es müsste anders reagiert werden. <br>
<br>
Die Kostenmodelle sind also hochkomplex. In diesem Bereich wird immernoch sehr viel Forschung betrieben. Der beste Optimierer wurde bis heute noch nicht gefunden.</p>
</section>
<section id="ausblick-auf-dbs-ii">
<h3><span class="section-number">12.4.12. </span>Ausblick auf DBS II<a class="headerlink" href="#ausblick-auf-dbs-ii" title="Permalink to this headline">#</a></h3>
<p>In DBS II geht es mit folgenden Themen weiter:</p>
<ul class="simple">
<li><p>diverse Algorithmen für einzelne Operatoren, insbesondere bei Joins und Sortierungen.</p></li>
<li><p>Kostenmodelle/Kostenschätzung</p></li>
<li><p>Optimale Joinreihenfolge: Dynamische Programmierung</p></li>
<li><p>Physische Anfragepläne und Pipelining</p></li>
</ul>
<p>Hier sind Tabellen gegeben mit denen man schauen kann, welche Pläne für welche Kombinationen gut funktionieren. Alle Punkte in diesen Diagrammen sind Pläne, die infrage kommen, für bestimmte Konstellationen von diesen Tabellen.
<img alt="" src="../_images/ausblick.jpg" /></p>
</section>
</section>
<section id="multiple-choice">
<h2><span class="section-number">12.5. </span>Multiple Choice<a class="headerlink" href="#multiple-choice" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Die hier verwendete Version des Multiple-Choice-Trainers von EILD.nrw wird nur in das JupyterBook eingebunden und nicht selbst gehostet. Der Multiple-Choice-Trainer wird durch GitHub-Pages gehostet.</p></li>
<li><p>Alle Fragen und Kategorien befinden sich zurzeit in Überarbeitung und sind nicht final.</p></li>
</ul>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="100%"
            height="800"
            src="https://lejuliennn.github.io/mct-trainer/#/quiz/categories/bearbeitung"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./12"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../11/transaktionen.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">11. </span>Transaktionsmanagement</p>
        </div>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Prof. Dr. Ziawasch Abedjan<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>