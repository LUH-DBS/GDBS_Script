
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>11. Transaktionsmanagement &#8212; Online-Skript Grundlagen der Datenbanksysteme</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. Bearbeitung" href="../12/bearbeitung.html" />
    <link rel="prev" title="10. Integrität und Trigger" href="../10/integritaet_und_trigger.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/DBIS_Kurzlogo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Online-Skript Grundlagen der Datenbanksysteme</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Grundlagen der Datenbanksysteme
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../01/einfuehrung.html">
   1. Einführung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../02/historie.html">
   2. Historie
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../03/architektur.html">
   3. Architektur
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/phasenmodell_datenbankentwurf.html">
   4. Phasenmodell für den Datenbankentwurf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../05/er_modellierung.html">
   5. ER-Modellierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../06/relationaler_entwurf.html">
   6. Relationaler Entwurf
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../07/normalisierung.html">
   7. Normalisierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../08/relationale_algebra.html">
   8. Relationale Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../09/sql.html">
   9. SQL
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../10/integritaet_und_trigger.html">
   10. Integrität und Trigger
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   11. Transaktionsmanagement
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../12/bearbeitung.html">
   12. Bearbeitung
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/LUH-DBS/GDBS_Script/main/?urlpath=tree/11/transaktionen.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        
<button onclick="initThebeSBT()"
  class="headerbtn headerbtn-launch-thebe"
  data-toggle="tooltip"
data-placement="left"
title="Launch Thebe"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="headerbtn__text-container">Live Code</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/LUH-DBS/GDBS_Script"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F11/transaktionen.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/11/transaktionen.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivation-transaktionsmanagement">
   11.1. Motivation - Transaktionsmanagement
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#motivierendes-beispiel">
     11.1.1. Motivierendes Beispiel
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#transaktionen">
   11.2. Transaktionen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#transaktionen-historie">
     11.2.1. Transaktionen – Historie
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#acid">
     11.2.2. ACID
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispielszenarien">
     11.2.3. Beispielszenarien
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispiel-serialisierbarkeit">
     11.2.4. Beispiel – Serialisierbarkeit
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispiel-atomizitat">
     11.2.5. Beispiel - Atomizität
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#probleme-im-mehrbenutzerbetrieb">
     11.2.6. Probleme im Mehrbenutzerbetrieb
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dirty-read">
     11.2.7. Dirty Read
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nonrepeatable-read">
     11.2.8. Nonrepeatable Read
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#das-phantom-problem">
     11.2.9. Das Phantom-Problem
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lost-update">
     11.2.10. Lost Update
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#transaktionen-in-sql">
     11.2.11. Transaktionen in SQL
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#isolationsebenen">
     11.2.12. Isolationsebenen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bedeutung-der-isolationsebenen">
     11.2.13. Bedeutung der Isolationsebenen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#isolationsebenen-ubersicht">
     11.2.14. Isolationsebenen – Übersicht
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#serialisierbarkeit">
   11.3. Serialisierbarkeit
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#seriell-vs-parallel">
     11.3.1. Seriell vs. Parallel
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schedules">
     11.3.2. Schedules
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#serielle-und-serialisierbare-schedules">
       11.3.2.1. Serielle und serialisierbare Schedules
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#konfliktserialisierbarkeit">
   11.4. Konfliktserialisierbarkeit
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#konflikte">
     11.4.1. Konflikte
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#konfliktserialisierbarkeit-vs-serialisierbarkeit">
       11.4.1.1. Konfliktserialisierbarkeit vs. Serialisierbarkeit
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#graphbasierter-test">
     11.4.2. Graphbasierter Test
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beweis">
     11.4.3. Beweis
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sperrkontrolle">
   11.5. Sperrkontrolle
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#scheduler">
     11.5.1. Scheduler
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sperren">
     11.5.2. Sperren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schedules-mit-sperren">
     11.5.3. Schedules mit Sperren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#freigabe-durch-scheduler">
     11.5.4. Freigabe durch Scheduler
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     11.5.5. Schedules mit Sperren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#phasen-sperrprotokoll">
     11.5.6. 2-Phasen Sperrprotokoll
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#phasen-sperrprotokoll-beispiel">
       11.5.6.1. 2-Phasen Sperrprotokoll – Beispiel
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#deadlocks-unter-2pl-moglich">
       11.5.6.2. Deadlocks unter 2PL möglich
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pl-intuition">
       11.5.6.3. 2PL – Intuition
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pl-beweis">
       11.5.6.4. 2PL – Beweis
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mehrere-sperrmodi">
     11.5.7. Mehrere Sperrmodi
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bedingungen">
     11.5.8. Bedingungen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#weitere-sperrarten">
     11.5.9. Weitere Sperrarten
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fragen">
   11.6. Fragen
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Transaktionsmanagement</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivation-transaktionsmanagement">
   11.1. Motivation - Transaktionsmanagement
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#motivierendes-beispiel">
     11.1.1. Motivierendes Beispiel
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#transaktionen">
   11.2. Transaktionen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#transaktionen-historie">
     11.2.1. Transaktionen – Historie
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#acid">
     11.2.2. ACID
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispielszenarien">
     11.2.3. Beispielszenarien
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispiel-serialisierbarkeit">
     11.2.4. Beispiel – Serialisierbarkeit
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beispiel-atomizitat">
     11.2.5. Beispiel - Atomizität
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#probleme-im-mehrbenutzerbetrieb">
     11.2.6. Probleme im Mehrbenutzerbetrieb
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dirty-read">
     11.2.7. Dirty Read
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nonrepeatable-read">
     11.2.8. Nonrepeatable Read
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#das-phantom-problem">
     11.2.9. Das Phantom-Problem
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lost-update">
     11.2.10. Lost Update
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#transaktionen-in-sql">
     11.2.11. Transaktionen in SQL
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#isolationsebenen">
     11.2.12. Isolationsebenen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bedeutung-der-isolationsebenen">
     11.2.13. Bedeutung der Isolationsebenen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#isolationsebenen-ubersicht">
     11.2.14. Isolationsebenen – Übersicht
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#serialisierbarkeit">
   11.3. Serialisierbarkeit
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#seriell-vs-parallel">
     11.3.1. Seriell vs. Parallel
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schedules">
     11.3.2. Schedules
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#serielle-und-serialisierbare-schedules">
       11.3.2.1. Serielle und serialisierbare Schedules
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#konfliktserialisierbarkeit">
   11.4. Konfliktserialisierbarkeit
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#konflikte">
     11.4.1. Konflikte
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#konfliktserialisierbarkeit-vs-serialisierbarkeit">
       11.4.1.1. Konfliktserialisierbarkeit vs. Serialisierbarkeit
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#graphbasierter-test">
     11.4.2. Graphbasierter Test
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#beweis">
     11.4.3. Beweis
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sperrkontrolle">
   11.5. Sperrkontrolle
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#scheduler">
     11.5.1. Scheduler
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sperren">
     11.5.2. Sperren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schedules-mit-sperren">
     11.5.3. Schedules mit Sperren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#freigabe-durch-scheduler">
     11.5.4. Freigabe durch Scheduler
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     11.5.5. Schedules mit Sperren
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#phasen-sperrprotokoll">
     11.5.6. 2-Phasen Sperrprotokoll
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#phasen-sperrprotokoll-beispiel">
       11.5.6.1. 2-Phasen Sperrprotokoll – Beispiel
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#deadlocks-unter-2pl-moglich">
       11.5.6.2. Deadlocks unter 2PL möglich
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pl-intuition">
       11.5.6.3. 2PL – Intuition
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pl-beweis">
       11.5.6.4. 2PL – Beweis
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mehrere-sperrmodi">
     11.5.7. Mehrere Sperrmodi
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bedingungen">
     11.5.8. Bedingungen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#weitere-sperrarten">
     11.5.9. Weitere Sperrarten
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fragen">
   11.6. Fragen
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="transaktionsmanagement">
<h1><span class="section-number">11. </span>Transaktionsmanagement<a class="headerlink" href="#transaktionsmanagement" title="Permalink to this headline">#</a></h1>
<p><img alt="title" src="../_images/cartoon.jpg" /></p>
<section id="motivation-transaktionsmanagement">
<h2><span class="section-number">11.1. </span>Motivation - Transaktionsmanagement<a class="headerlink" href="#motivation-transaktionsmanagement" title="Permalink to this headline">#</a></h2>
<p><br><br>
Bisher haben wir in unseren Beispielen angenommen, dass nur ein Nutzer auf die Datenbank zugreift(Isolation). In der Realität werden in Betrieb genommene Datenbanken, von vielen Nutzern und Anwendungen gleichzeitig lesend und schreiben genutzt. Weiterhin haben wir angenommen, dass Anfragen und Updates aus einer einzigen atomaren Aktion bestehen, in der die DBMS nicht mitten ausfallen kann(Atomizität). Jedoch bestehen einfache Anfragen in Wahrheit oft aus mehreren Teilschritten.</p>
<section id="motivierendes-beispiel">
<h3><span class="section-number">11.1.1. </span>Motivierendes Beispiel<a class="headerlink" href="#motivierendes-beispiel" title="Permalink to this headline">#</a></h3>
<p>Betrachten wir folgendes Beispiel. Zwei Personen Philipp und Sarah teilen sich ein Konto und können dies bearbeiten. Der aktuelle Kontostand beträgt 500. In der Tabelle werden die Bearbeitungen von Philipp und Sarah dargestellt, wobei eine Zeile einen Zeitpunkt darstellt, in der Operationen ausgeführt werden.
<br><br>
Zuerst liest Sarah den Wert des Kontos und speichert diesen in die Variable y. Danach macht Philipp dasselbe und speichert den Wert in x. Philipp zahlt weitere 200 auf den Kontostand und commitet dies. Sarah nimmt danach 100 aus dem Konto, jedoch wird mit dem alten Kontostand 500 weitergerechnet. Der falsche Wert 400 wird commitet, obwohl auf dem Konto 600 sein sollten. Dieses Beispiel stellt einen Non-repeatble Read dar, ein Problem aus einere Reihe von Problemen, die eine DBMS in inkonsiste Zustände führen kann. Die Probleme werden wir in diesem Kapitel kennenlernen.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Kontostand: 500</strong></p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Philipp</strong></p></td>
<td><p><strong>Sarah</strong></p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>read(K,y)</p></td>
</tr>
<tr class="row-even"><td><p>read(K,x)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>x:=x+200</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>write(x,K)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>y:=y-100</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>write(y,K)</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Kontostand: 400</strong></p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="transaktionen">
<h2><span class="section-number">11.2. </span>Transaktionen<a class="headerlink" href="#transaktionen" title="Permalink to this headline">#</a></h2>
<p>Eine Transaktion ist eine Folge von Operationen (Aktionen), die die Datenbank von einem konsistenten Zustand in einen konsistenten (eventuell veränderten) Zustand überführt, wobei das ACID-Prinzip eingehalten werden muss.</p>
<section id="transaktionen-historie">
<h3><span class="section-number">11.2.1. </span>Transaktionen – Historie<a class="headerlink" href="#transaktionen-historie" title="Permalink to this headline">#</a></h3>
<p>In alten DBMS wurde kein Formalismus über Transaktionen implementiert, sondern lediglich nur Tricks benutzt. Die ersten (ineffiziente) Implementierung von Formalismen, wurde in den 80ern von Jim Gray(ACM Turing Award), mit dem System R eingeführt. Eine weitere wichtige Person, ist C. Mohan, der im ARIES Project vom IBM Reasearch, der mit Algorithms for Recovery and Isolation Exploiting Semantics effiziente Implementierungen, insbesondere im Bereich von Transaktionen in verteilten Anwendungen und Services, entwickelt hat.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-center head"><p>C. Mohan</p></th>
<th class="text-center head"><p>Jim Gray</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><a class="reference internal" href="../_images/c_mohan.jpg"><img alt="../_images/c_mohan.jpg" src="../_images/c_mohan.jpg" style="width: 400px;" /></a></p></td>
<td class="text-center"><p><a class="reference internal" href="../_images/jim_gray.jpg"><img alt="../_images/jim_gray.jpg" src="../_images/jim_gray.jpg" style="width: 400px;" /></a></p></td>
</tr>
</tbody>
</table>
</section>
<section id="acid">
<h3><span class="section-number">11.2.2. </span>ACID<a class="headerlink" href="#acid" title="Permalink to this headline">#</a></h3>
<p>Das ACID-Prinzip stellt die Eigenschaften einer Transaktion, es wird aus folgenden Teilprinzipien zusammengesetzt:
<br><br></p>
<ul class="simple">
<li><p>Atomicity (Atomarität): Eine Transaktion wird entweder ganz oder gar nicht ausgeführt.
<br><br></p></li>
<li><p>Consistency (Konsistenz oder auch Integritätserhaltung): Die Datenbank ist vor Beginn und nach Beendigung einer Transaktion jeweils in einem konsistenten Zustand.
<br><br></p></li>
<li><p>Isolation (Isolation): Eine Transaktion, die auf einer Datenbank arbeitet, sollte den „Eindruck“ haben, dass sie allein auf dieser Datenbank arbeitet.
<br><br></p></li>
<li><p>Durability (Dauerhaftigkeit / Persistenz): Nach erfolgreichem Abschluss einer Transaktion, muss das Ergebnis dieser Transaktion „dauerhaft“ in der Datenbank gespeichert werden.</p></li>
</ul>
</section>
<section id="beispielszenarien">
<h3><span class="section-number">11.2.3. </span>Beispielszenarien<a class="headerlink" href="#beispielszenarien" title="Permalink to this headline">#</a></h3>
<p>Einige Beispieszenarien für Probleme im Transaktionsmanagement sind z.b die Platzreservierung für Flüge aus vielen Reisebüros gelichzeitig. Ein Platz könnte mehrfach verkauft werden, wenn mehrere Reisebüros den Platz als verfügbar identifizieren. Ein weiteres Beispiel sind überschneidende Konto-Operationen einer Bank, wie im ersten Beispiel des Kapitels zu sehen ist. Auch bei statistischen Datenbankoperationen kann es zu Problemen kommen, wenn während der Berechnung Daten geändert werden, s.d. die Ergebnisse verfälscht sind.</p>
</section>
<section id="beispiel-serialisierbarkeit">
<h3><span class="section-number">11.2.4. </span>Beispiel – Serialisierbarkeit<a class="headerlink" href="#beispiel-serialisierbarkeit" title="Permalink to this headline">#</a></h3>
<p>In diesem Beispiel haben wir die Relation Fluege(Flugnummer, Datum, Sitz, besetzt) gegeben. Zusätzlich haben wir eine Funktion chooseSeat(), die nach einem freiem Platz sucht und ihn gegebenenfalls besetzt. Unten sehen Sie einen Embedded-SQL-Codeausschnitt.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>EXEC SQL BEGIN DECLARE SECTION;
    int flug;
    char date[10];
    char seat[3];
    int occ;
EXEC SQL END DECLARE SECTION;

void chooseSeat() {
/* Nutzer nach Flug, Datum und Sitz fragen */
    EXEC SQL SELECT besetzt INTO :occ FROM Fluege
        WHERE Flugnummer=:flug
        AND Datum=:date AND Sitz=:seat;
if(!occ) {
        EXEC SQL UPDATE Fluege SET besetzt=TRUE
    WHERE Flugnummer=:flight AND Datum=:date AND Sitz=:seat;
        }
    else …
}
</pre></div>
</div>
<p>Problematisch wird es, wenn die Funktion chooseSeat() von mehreren Usern zugleich aufgerufen wird. Wir haben User 1 und 2. User 1 findet zuerst einen leeren Platz, aber dieser besetzt ihn noch nicht. User 2 findet denselben leren Platz. Nachdem User 2 denselben leeren Platz, wie User 1 gefunden hat, besetzt User 1 diesen. Zuletzt besetzt auch User 2 diesen. Das Problem ist, dass beide User glauben den Platz reserviert zu haben. Die Lösung für diese Problem, ist das beide Transaktionen (eine Spalte stellt eine Transaktion dar) in serielle oder serialisierbare Schedules umgewandelt werden, wir wir im Weiteren kennenlernen werden.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schedule</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>User 1 findet leeren Platz</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>User 2 findet leeren Platz</p></td>
</tr>
<tr class="row-even"><td><p>User 1 besetzt Platz</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>User 2 besetzt Platz</p></td>
</tr>
</tbody>
</table>
</section>
<section id="beispiel-atomizitat">
<h3><span class="section-number">11.2.5. </span>Beispiel - Atomizität<a class="headerlink" href="#beispiel-atomizitat" title="Permalink to this headline">#</a></h3>
<p>In diesem Beispiel möchten wir einen Betrag von konto1 auf konto2 überweisen. Zuerst wird überprüft, ob konto1 überhaupt genug Geld hat, um den geforderten Betrag zu überweisen. Ist dies der Fall wird der Betrag auf konto2 gutgeschrieben. Nun kann es sein, dass das System in diesem Moment abstürzt. Der Betrag wurde auf konto2 gutgeschrieben, jedoch noch nicht von konto1 abgezogen. Es ist möglich, dass die Datenbank in einen inkonsistenten Zustand hinterlassen wird. Lösung für diese Problem ist Atomizität. In diesem Fall würden die vorherigen Transaktionsschritte verworfen werden, da eine Transaktion nach dem Atomizitäts-Prinzip nur ganz oder garnicht ausgeführt wird.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">EXEC</span> <span class="n">SQL</span> <span class="n">BEGIN</span> <span class="n">SECTION</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">konto1</span><span class="p">,</span> <span class="n">konto2</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">kontostand</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">betrag</span><span class="p">;</span>
<span class="n">EXEC</span> <span class="n">SQL</span> <span class="n">END</span> <span class="n">DECLARE</span> <span class="n">SECTION</span><span class="p">;</span>
<span class="n">void</span> <span class="n">transfer</span><span class="p">()</span> <span class="p">{</span>
<span class="o">/*</span> <span class="n">User</span> <span class="n">nach</span> <span class="n">Konto1</span><span class="p">,</span> <span class="n">Konto2</span> <span class="n">und</span> <span class="n">Betrag</span> <span class="n">fragen</span> <span class="o">*/</span>
    <span class="n">EXEC</span> <span class="n">SQL</span> <span class="n">SELECT</span> <span class="n">Stand</span> <span class="n">INTO</span> <span class="p">:</span><span class="n">kontostand</span> <span class="n">FROM</span> <span class="n">Konten</span>
        <span class="n">WHERE</span> <span class="n">KontoNR</span><span class="o">=</span><span class="p">:</span><span class="n">konto1</span><span class="p">;</span>
        <span class="n">If</span> <span class="p">(</span><span class="n">kontostand</span> <span class="o">&gt;=</span> <span class="n">betrag</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">EXEC</span> <span class="n">SQL</span> <span class="n">UPDATE</span> <span class="n">Konten</span>
        <span class="n">SET</span> <span class="n">Stand</span><span class="o">=</span><span class="n">Stand</span><span class="o">+</span><span class="p">:</span><span class="n">betrag</span>
        <span class="n">WHERE</span> <span class="n">KontoNR</span><span class="o">=</span><span class="p">:</span><span class="n">konto2</span><span class="p">;</span>
    <span class="n">EXEC</span> <span class="n">SQL</span> <span class="n">UPDATE</span> <span class="n">Konten</span>
        <span class="n">SET</span> <span class="n">Stand</span><span class="o">=</span><span class="n">Stand</span><span class="o">-</span><span class="p">:</span><span class="n">betrag</span>
        <span class="n">WHERE</span> <span class="n">KontoNR</span><span class="o">=</span><span class="p">:</span><span class="n">konto1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="o">/*</span> <span class="n">Fehlermeldung</span> <span class="o">*/</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="probleme-im-mehrbenutzerbetrieb">
<h3><span class="section-number">11.2.6. </span>Probleme im Mehrbenutzerbetrieb<a class="headerlink" href="#probleme-im-mehrbenutzerbetrieb" title="Permalink to this headline">#</a></h3>
<p>In diesem Kapitel beschäftigen wir uns mit vier bekannnten Problemen, die im Mehrbenutzerbetrieb auftreten können.</p>
<ul class="simple">
<li><p>Dirty Read: Abhängigkeiten von nicht freigegebenen Daten</p></li>
<li><p>Nonrepeatable Read: Inkonsistentes Lesen</p></li>
<li><p>Phantom-Problem: Berechnungen auf unvollständigen Daten</p></li>
<li><p>Lost Update: Verlorengegangenes Ändern</p></li>
</ul>
</section>
<section id="dirty-read">
<h3><span class="section-number">11.2.7. </span>Dirty Read<a class="headerlink" href="#dirty-read" title="Permalink to this headline">#</a></h3>
<p>Wir haben zwei Transaktionen T1 und T2 gegeben. Zuerst wird in T1 aus der Tabelle A der Wert ausgelesen und in x gespeichert. Auf x wird dann 100 addiert und der Wert von x wird in die Tabelle A geschrieben. Die Transaktion T1 ist jedoch noch nicht commitet. Währenddessen werden in T2 die Werte aus den Tabellen A und B gelesen und in die Variablen x und y gespeichert. Es wird die Summe aus x und y gebildet, wobei der Wert in x aus T2 den Wert x:=x+100 aus T1 hat. Die Summe wird in T2 in die Tabelle B geschrieben und es wird commitet. Zuletzt findet ein abort in T1 statt, welches den Effekt hat, dass die vorherigen Transaktionsschritte aus T1 verworfen werden. Das Problem ist, dass T2  den veränderten A-Wert liest, diese Änderung aber nicht endgültig ist, sondern sogar ungültig.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>read(A,x)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>x:=x+100</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>write(x,A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>read(A,x)</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>read(B,y)</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>y:=y+x</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>write(y,B)</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-even"><td><p>abort</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
<p>Folie nach Kai-Uwe Sattler (TU Ilmenau)</p>
</section>
<section id="nonrepeatable-read">
<h3><span class="section-number">11.2.8. </span>Nonrepeatable Read<a class="headerlink" href="#nonrepeatable-read" title="Permalink to this headline">#</a></h3>
<p>Im Folgenden betrachten wir ein Beispiel für Nicht-wiederholbares Lesen. In unserem Beispiel möchten wir die Zusicherung haben, dass x = A + B + C am Ende der Transaktion T1 gilt, wobei x, y, z lokale Variablen seien.
<br><br>
Zuerst wird in T1 der Wert aus A gelesen und in x gespeichert. Danach wird in T2 der Wert von A halbiert und auf den Wert von C wird der neue Wert von A addiert. Die Änderungen aus T2 werden commitet. Anschließend wird in T1 der Wert aus B und C gelesen und auf x addiert. Das Problem ist, dass der Wert x in T1 nicht mehr nachvollzogen werden kann, da A sich im Laufe der Transaktion geändert hat. Zuletzt ist x = A + B + C + A/2.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>read(A,x)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>read(A,y)</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>y:=y/2</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>write(y,A)</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>read(C,z)</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>z:=z+y</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>write(z,C)</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-even"><td><p>read(B,y)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>x:=x+y</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>read(C,z)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>x:=x+z</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
<p>Beispiel nach Kai-Uwe Sattler (TU Ilmenau)</p>
</section>
<section id="das-phantom-problem">
<h3><span class="section-number">11.2.9. </span>Das Phantom-Problem<a class="headerlink" href="#das-phantom-problem" title="Permalink to this headline">#</a></h3>
<p>In diesem Beispiel haben wir ein Budget von 1000 gegeben und möchten dies gleichmäßig auf die Gehälter aller Mitarbeiter*Innen aufteilen. In T1 wird zuerst die Anzahl der Mitarbeiter*Innen in die Variable x gespeichert. Danach wird in T2 ein weiterer Mitarbeiter in die Tabelle eingefügt und commitet. Anschließend wird in T1 das Budget auf die Gehälter aller Mitarbeiter*Innen verteilt. Jedoch ist der Mitarbeiter Meier nicht in die Gehaltsabrechnung eingegangen. Tatsächlich müsste es SET Gehalt = Gehalt +10000/(X+1) sein. Meier ist das Phantom.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SELECT COUNT(*)<br>INTO X<br>FROM Mitarbeiter</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>INSERT INTO Mitarbeiter<br>VALUES (‚Meier‘, 50000, …)</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-odd"><td><p>UPDATE Mitarbeiter<br>SET Gehalt = Gehalt +10000/X</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
<p>Beispiel nach Kai-Uwe Sattler (TU Ilmenau)</p>
<p><img alt="title" src="../_images/phantom.jpg" />
<br></p>
</section>
<section id="lost-update">
<h3><span class="section-number">11.2.10. </span>Lost Update<a class="headerlink" href="#lost-update" title="Permalink to this headline">#</a></h3>
<p>Bei diesem Beispiel für ein Lost Update, lesen T1 und T2 den Wert aus A, welcher 10 ist. T1 addiert Eins dazu und T2 addiert ebenfalls Eins dazu. Beide schreiben den Wert wieder in A. Jedoch wird die Erhöhung von T1 nicht berücksichtigt. In diesem Fall hätte man gerne die Veränderung von T1 vor dem Lesen in T2 erkannt.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
<th class="head"><p>A</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>read(A,x)</p></td>
<td><p>﻿</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>read(A,x)</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p>x:=x+1</p></td>
<td><p>﻿</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>x:=x+1</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p>write(x,A)</p></td>
<td><p>﻿</p></td>
<td><p>11</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>write(x,A)</p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
<p>Folie nach Kai-Uwe Sattler (TU Ilmenau)</p>
</section>
<section id="transaktionen-in-sql">
<h3><span class="section-number">11.2.11. </span>Transaktionen in SQL<a class="headerlink" href="#transaktionen-in-sql" title="Permalink to this headline">#</a></h3>
<p>In SQL werden mehrere Operationen/Anfragen in eine Transaktion gruppiert. Ein SQL Befehl entspricht einer Transaktion. Die Transaktionen werden per Definition atomar und per SQL Standard serialisierbar ausgeführt. Diese Regeln können auch aufgeweicht werden s. Isolationsebenen. Ausgelöste TRIGGER werden ebenfalls innerhalb der Transaktion ausgeführt. Explizit kann der Beginn einer Transaktion mit START TRANSACTION deklariert werden. Das Ende einer Transaktion (falls mit START TRANSACTION gestartet), kann mit COMMIT(erfolgreiches Ende der Transaktion) oder mit ROLLBACK oder ABORT(Scheitern der Transaktion) signalisiert werden. Beim zweiten werden schon erfolgte Änderungen rückgängig gemacht. In nötigen Fällen werden von der DBMS selbst ROLLBACK oder ABORT ausgelöst, die entsprechende Fehlermeldung muss dann von der Anwendung erkannt werden.</p>
</section>
<section id="isolationsebenen">
<h3><span class="section-number">11.2.12. </span>Isolationsebenen<a class="headerlink" href="#isolationsebenen" title="Permalink to this headline">#</a></h3>
<p>Das Aufweichen von ACID in SQL-92 ist mit sogenannten Isolationsebenen möglich. Pro Transaktion können weniger einschränkende Regeln wie z.B read uncommited o.Ä. festgelegt werden. Die weiteren Ebenen dienen als Hilfestellung für das DBSM zu Effizienzsteigerung.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">transaction</span>
<span class="p">[</span> <span class="p">{</span> <span class="n">read</span> <span class="n">only</span> <span class="o">|</span> <span class="n">read</span> <span class="n">write</span> <span class="p">},</span> <span class="p">]</span>
<span class="p">[</span><span class="n">isolation</span> <span class="n">level</span> <span class="p">{</span>
    <span class="n">read</span> <span class="n">uncommitted</span> <span class="o">|</span>
    <span class="n">read</span> <span class="n">committed</span> <span class="o">|</span>
    <span class="n">repeatable</span> <span class="n">read</span> <span class="o">|</span>
    <span class="n">serializable</span> <span class="p">},</span> <span class="p">]</span>
<span class="p">[</span> <span class="n">diagnostics</span> <span class="n">size</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Die Standardeinstellung ist die strengste Form und sieht wie folgt aus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">transaction</span> <span class="n">read</span> <span class="n">write</span><span class="p">,</span>
<span class="n">isolation</span> <span class="n">level</span> <span class="n">serializable</span>
</pre></div>
</div>
</section>
<section id="bedeutung-der-isolationsebenen">
<h3><span class="section-number">11.2.13. </span>Bedeutung der Isolationsebenen<a class="headerlink" href="#bedeutung-der-isolationsebenen" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>read uncommitted: Diese Isolationsebene ist die schwächste Stufe und erlaubt den Zugriff auf nicht geschriebene Daten. Falls geschrieben werden soll muss read write angegeben werden, da hier ausnahmsweise der default read only ist. Durch das Weglassen von Sperren, wird die Effiezenz gesteigert, da keine Transaktionen behindert werden.
<br><br></p></li>
<li><p>read committed: Mit dieser Isolationsebene dürfen nur endgültig geschriebene Werte gelesen werden, jedoh ist  nonrepeatable read immernoch möglich.
<br><br></p></li>
<li><p>repeatable read: Bei dieser Isolationsebene sind nonrepeatable reads verhindert, aber das Phantomproblem kann auftreten.
<br><br></p></li>
<li><p>serializable: Bei der strengsten Isolationsebene wird Serialisierbarkeit (default) garantiert. Transaktion sehen nur Änderungen, die zu Beginn der Transaktion committed waren (und eigene Änderungen).</p></li>
</ul>
</section>
<section id="isolationsebenen-ubersicht">
<h3><span class="section-number">11.2.14. </span>Isolationsebenen – Übersicht<a class="headerlink" href="#isolationsebenen-ubersicht" title="Permalink to this headline">#</a></h3>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Isolationsebene</p></th>
<th class="head"><p>Dirty Read</p></th>
<th class="head"><p>Nonrepeatable Read</p></th>
<th class="head"><p>Phantom Read</p></th>
<th class="head"><p>Lost Update</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Read Uncommited</p></td>
<td><p>+</p></td>
<td><p>+</p></td>
<td><p>+</p></td>
<td><p>+</p></td>
</tr>
<tr class="row-odd"><td><p>Read Committed</p></td>
<td><p>-</p></td>
<td><p>+</p></td>
<td><p>+</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p>Repeatable Read</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>+</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>Serializable</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="serialisierbarkeit">
<h2><span class="section-number">11.3. </span>Serialisierbarkeit<a class="headerlink" href="#serialisierbarkeit" title="Permalink to this headline">#</a></h2>
<p>In diesem Kapitel beschäftigen wir uns mit der Serialisierbarkeit von Schedules.</p>
<section id="seriell-vs-parallel">
<h3><span class="section-number">11.3.1. </span>Seriell vs. Parallel<a class="headerlink" href="#seriell-vs-parallel" title="Permalink to this headline">#</a></h3>
<p>Unser Ziel ist, dass jede Transaktion, die isoliert auf einem konsistenten Zustand der Datenbank ausgeführt wird, die Datenbank wiederum in einem konsistenten Zustand hinterlässt(Korrektheit). Eine einfache Lösung aller obigen Probleme, wäre das alle Transaktion seriell, also nacheinander ausgeführt werden. Jedoch bietet parallele Ausführung Effizienvorteile, besonders bei „Long-Transactions“, die über mehrere Stunden hinweg laufen oder auch beim Zugriff auf den Cache. Daher ist es wichtig korrekte parallele Pläne(Schedules) zu finden. In diesem Kapitel werden wir lernen, dass mit korrekt serialisierbar gemeint ist.</p>
</section>
<section id="schedules">
<h3><span class="section-number">11.3.2. </span>Schedules<a class="headerlink" href="#schedules" title="Permalink to this headline">#</a></h3>
<p>Ein Schedule ist eine geordnete Abfolge wichtiger Aktionen, die von einer oder mehreren Transaktionen durchgeführt werden. Besonders wichtige Aktionen sind READ und WRITE eines Elements. Ein „Ablaufplan“ für eine Transaktion, legt die Abfolge der jeweiligen Transaktionsoperationen fest.
<br><br>
Wie im unteren Beispiel zu sehen ist, fängt ein Schedule mit “Begin TA” an und endet mit einem “commit”. Wir sehen zwei Transaktionen T1 und T3, in denen jeweil lokal ein Wert aus den Variablen A und B gelesen wird. Dieser Wert wird verändert und in den Variablen überschrieben. Der Effekt dieses parallelen Schedules ist unklar. Es ist möglich, dass Updates verloren gegangen sind oder das nachdem T1 gelesen bzw. geschrieben hat ,T3 gelesen bzw. geschrieben hat.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>Begin TA</p></td>
<td><p>Begin TA</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>read(A,a2)</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>a2 := a2 – 100</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>write(A,a2)</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>read(B,b2)</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>b2 := b2 + 100</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>write(B,b2)</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>commit</p></td>
<td><p>commit</p></td>
</tr>
</tbody>
</table>
<br> 
Beispiel: Alfons Kemper(TU München)
<section id="serielle-und-serialisierbare-schedules">
<h4><span class="section-number">11.3.2.1. </span>Serielle und serialisierbare Schedules<a class="headerlink" href="#serielle-und-serialisierbare-schedules" title="Permalink to this headline">#</a></h4>
<p>Ein serieller Schedule, ist ein Schedule in dem Transaktionen hintereinander ausgeführt werden.
<br><br>
Ein Schedule ist serialisierbarer, wenn ein serieller Schedule mit identischem Effekt existiert.
<br><br>
Wir sehen unten einen seriellen Schedule, in dem zuerst T1 und dann T2 ausgeführt wird. Daneben sehen wir einen nicht seriellen Schedule mit dem selben Effekt wie der serielle, also ist dieser serialisierbar.</p>
<table>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Serieller Schedule</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Schritt</strong></p></td>
<td><p><strong>T1</strong></p></td>
<td><p><strong>T2</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>2.</p></td>
<td><p>read(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>3.</p></td>
<td><p>write(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>4.</p></td>
<td><p>read(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>5.</p></td>
<td><p>write(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>6.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-even"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>read©</p></td>
</tr>
<tr class="row-odd"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>write©</p></td>
</tr>
<tr class="row-even"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>read(A)</p></td>
</tr>
<tr class="row-odd"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>write(A)</p></td>
</tr>
<tr class="row-even"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Serialisierbarer Schedule</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Schritt</strong></p></td>
<td><p><strong>T1</strong></p></td>
<td><p><strong>T2</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>2.</p></td>
<td><p>read(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>3.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-even"><td><p>4.</p></td>
<td><p>﻿</p></td>
<td><p>read©</p></td>
</tr>
<tr class="row-odd"><td><p>5.</p></td>
<td><p>write(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>write©</p></td>
</tr>
<tr class="row-odd"><td><p>7.</p></td>
<td><p>read(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>8.</p></td>
<td><p>write(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>9.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>read(A)</p></td>
</tr>
<tr class="row-odd"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>write(A)</p></td>
</tr>
<tr class="row-even"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
</tbody>
</table>
</table>
<br> 
Beispiel: Alfons Kemper(TU München)<p><br><br>
<strong>Beispiel 2</strong>
<br><br>
Nun fragen wir uns, ob der folgende Schedule serialisierbar ist. Wenn wir den unteren Schedule betrachten, sehen wir ,dass die read(A)write(A) bzw. read(B)write(B) Operationen von T1 abhänging von denen von T3 sind und umgekehrt. Bei den seriellen Schedules T1,T3 und T3,T1 würden Informationen verloren gehen, daher ist der Schedule unten nicht serialisierbar.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Serialisierbar?</p></th>
<th class="head"><p>﻿</p></th>
<th class="head"><p>﻿</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Schritt</strong></p></td>
<td><p><strong>T1</strong></p></td>
<td><p><strong>T3</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>2.</p></td>
<td><p>read(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>3.</p></td>
<td><p>write(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>4.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-odd"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>read(A)</p></td>
</tr>
<tr class="row-even"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>write(A)</p></td>
</tr>
<tr class="row-odd"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>read(B)</p></td>
</tr>
<tr class="row-even"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>write(B)</p></td>
</tr>
<tr class="row-odd"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-even"><td><p>10.</p></td>
<td><p>read(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>11.</p></td>
<td><p>write(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>12.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
<br> 
Beispiel: Alfons Kemper(TU München)<p><br><br>
<strong>Beispiel 2.1</strong>
<br><br>
Betrachten wir folgenden nicht seriellen Schedule. Zuerst wird in T1 der Wert aus A gelesen und um 50 verringert und geschrieben. Danach wird in T3 der Wert aus A gelesen und um 100 verringert und geschrieben. Folgend wird in T3 der Wert aus B gelesen und um 100 erhöht und geschrieben. Zuletzt wird in T1 der Wert aus B gelsen um 50 erhöht und geschrieben. Wir fragen uns, ob dieser Schedule serialisierbar ist?
<br><br>
Tatsächlich ist dieser Schedule theoretisch serialisierbar, da die Operationen von T1 und T3 aufeinander aufbauen. Es macht keinen Unterschied, ob zuerst 50 oder 100 von A abgezogen werden oder ob zuerst 50 oder 100 auf B addiert werden. Jedoch müssen wir immer vom schlimmsten Fall ausgehen und können nicht wissen, dass die Operationen aufeinander aufbauen. Daher ist der Schedule in der Realität nicht serialisierbar.</p>
<table>
    <tr><th>Nicht seriell, aber serialisierbar ? </th><th>Seriell</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 – 100</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 + 100</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 – 100</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 + 100</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
</tbody>
</table>
</table>
<p>Beide Schedules haben den folgenden Effekt: A = A − 150, B = B + 150.</p>
<br> 
Beispiel: Alfons Kemper(TU München)<p><strong>Beispiel 2.2</strong>
<br><br>
Dieses Beispiel ähnelt dem vorherigen, jedoch wird in T1 nur addiert und T3 wird nur multipliziert. Wenn wir nun einen seriellen Schedule wie oben erstellen, ist der Effekt nicht mehr identisch, da Punkt-vor-Strich-Rechnung eine Rolle spielt. Sowohl T1T3, als auch T3T1 haben nicht denselben Effekt. Dieses Beipiel soll nochmal veranschaulichen, dass der schlimmste Fall angenommen werden muss und der Schedule nicht serialisierbar ist.</p>
<table>
    <tr><th>Schedule 1 </th><th>Schedule 2: T1T3</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>100</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
<td><p>50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 * 1.03</p></td>
<td><p>51,5</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 * 1.03</p></td>
<td><p>﻿</p></td>
<td><p>103</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>153</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>Effekt: A = (A − 50) * 1.03 und B = B * 1.03 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>100</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
<td><p>50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>150</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>Commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 * 1.03</p></td>
<td><p>51,5</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 * 1.03</p></td>
<td><p>﻿</p></td>
<td><p>154,5</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>Effekt: A = (A − 50) * 1.03 und B = (B + 50) * 1.03</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</table>
<p><br><br></p>
<table>
    <tr><th>Schedule 1 </th><th>Schedule 3: T3T1</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>100</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
<td><p>50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 * 1.03</p></td>
<td><p>51,5</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 * 1.03</p></td>
<td><p>﻿</p></td>
<td><p>103</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>153</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>Effekt: A = (A − 50) * 1.03 und B = B * 1.03 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
<td><p>100</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 * 1.03</p></td>
<td><p>103</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 * 1.03</p></td>
<td><p>﻿</p></td>
<td><p>103</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
<td><p>53</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>153</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>Effekt: A = A * 1.03 − 50 und B = B * 1.03 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</table>
<br> 
Beispiel: Alfons Kemper(TU München)<p><br><br>
<strong>Zusammenfassung Beispiel 2</strong>
<br><br>
Betrachten wir erneut unser Ursprungsbeispiel. Dieser Schedule ist nicht serialisierbar, denn obwohl es konkrete Beispiele solcher Transaktionen gibt, für die es einen äquivalenten seriellen Schedule gibt. Muss immer das Schlimmste angenommen.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>write(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>read(A)</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>write(A)</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>read(B)</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>write(B)</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>read(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>write(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
<br> 
Beispiel: Alfons Kemper(TU München)<p><br><br>
<strong>Beispiel 3</strong>
<br><br>
Wenn wir uns nochmal die beiden seriellen Schedules T1T3 und T3T1 anschauen. Es fällt auf, dass T1T3 ≠ T3T1 ist. Hier muss nun die Applikation entscheiden, welche Reihenfolge logisch Sinn ergibt.</p>
<table>
    <tr><th>Schedule 1:T1T3 </th><th>Schedule 2: T3T1</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>100</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
<td><p>50</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>150</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>Commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 * 1.03</p></td>
<td><p>51,5</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 * 1.03</p></td>
<td><p>﻿</p></td>
<td><p>154,5</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
<td><p>100</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>﻿</p></td>
<td><p>read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>﻿</p></td>
<td><p>a2 := a2 * 1.03</p></td>
<td><p>103</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>﻿</p></td>
<td><p>write(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>b2 := b2 * 1.03</p></td>
<td><p>﻿</p></td>
<td><p>103</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>write(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>a1 := a1 – 50</p></td>
<td><p>﻿</p></td>
<td><p>53</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>write(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>13.</p></td>
<td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>14.</p></td>
<td><p>b1 := b1 + 50</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>153</p></td>
</tr>
<tr class="row-even"><td><p>15.</p></td>
<td><p>write(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>16.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</table>
<br> 
Beispiel: Alfons Kemper(TU München)</section>
</section>
</section>
<section id="konfliktserialisierbarkeit">
<h2><span class="section-number">11.4. </span>Konfliktserialisierbarkeit<a class="headerlink" href="#konfliktserialisierbarkeit" title="Permalink to this headline">#</a></h2>
<p>In diesem Kapitel wollen wir eine Methode kennenlernen, um die Serialisierbarkeit von Schedules zu überprüfen. Wir werden thematisieren wann ein Konflikt zwischen zwei oder mehr Transaktionen herrscht und wie ein äquivalenter serieller Schedule ermittelt werden kann.</p>
<section id="konflikte">
<h3><span class="section-number">11.4.1. </span>Konflikte<a class="headerlink" href="#konflikte" title="Permalink to this headline">#</a></h3>
<p>Konfliktserialisierbarkeit ist eine Bedingung für die Serilisierbarkeit und wird von den meisten DBMS verlangt (und hergestellt). Ein Konflikt herrscht zwischen zwei Aktionen eines Schedules, falls die Änderung ihrer Reihenfolge das Ergebnis verändern kann, dies passiert insbesondere bei read-/write-Operationen.
<br><br>
In diesem Kontext lernen wir eine neue Notation von read-/write-Operationen kennen, undzwar schreiben wir ri(x) bzw. wi(x), wobei i die TransaktionID ist und X das Datenbankelement. Mit dieser neuen Notation lassen sich Transaktionen(Sequenz solcher Aktionen) in einer Zeilenform wie z.B r1(A)w1(A)r1(B)w1(B) schreiben. Ein Schedule ist eine Menge von solchen Transaktionen in Zeilenform, welche alle Transaktionen enthalten müssen. Zudem erscheinen die Aktionen einer Transaktion im Schedule in gleicher Reihenfolge.
<br><br>
Angenommen wir haben die Transaktionen Ti und Tk gegegeben. Nun gelten folgende Regeln:
<br></p>
<ul class="simple">
<li><p>ri(X) und rk(X) stehen nicht in Konflikt
<br></p></li>
<li><p>ri(X) und wk(Y) stehen nicht in Konflikt (falls X ≠ Y)
<br></p></li>
<li><p>wi(X) und rk(Y) stehen nicht in Konflikt (falls X ≠ Y)
<br></p></li>
<li><p>wi(X) und wk(Y) stehen nicht in Konflikt (falls X ≠ Y)
<br></p></li>
<li><p>ri(X) und wk(X) stehen in Konflikt
<br></p></li>
<li><p>wi(X) und rk(X) stehen in Konflikt
<br></p></li>
<li><p>wi(X) und wk(X) stehen in Konflikt
<br></p></li>
</ul>
<p>Es gilt „No coincidences“. Man nimmt immer das schlimmste an. Die konkrete Ausprägung der write-Operationen ist egal.
<br><br>
Zusammenfassend kann gesagt werden, dass ein Konflikt herrscht falls zwei Aktionen das gleiche Datenbankelement betreffen und mindestens eine der beiden Aktionen ein write ist.</p>
<p>Haben wir einen Schedule gegeben, können wir so lange nicht-konfligierende Aktionen tauschen, bis aus dem Schedule ein serieller Schedule wird. Falls das erfolgreich ist, ist der Schedule serialisierbar.
<br><br>
Zwei Schedules S und S‘ heißen <strong>konfliktäquivalent</strong>, wenn die Reihenfolge aller Paare von konfligierenden Aktionen in beiden Schedules gleich ist.
<br><br>
Ein Schedule S ist genau dann <strong>konfliktserialisierbar</strong>, wenn S konfliktäquivalent zu einem seriellen Schedule ist.
<br><br>
Betrachten wir nun folgenden Schedule, bestehend aus zwei Transaktionen. Wir wollen nun den Schedule in einen seriellen Schedule umwandeln:
<br>
r1(A) w1(A) r2(A) w2(A) r2(B) w2(B) r1(B) w1(B)
<br><br>
Serieller Schedule T1T2:
<br>
r1(A) w1(A) r1(B) w1(B) r2(A) w2(A) r2(B) w2(B)
<br><br>
Serieller Schedule T2T1:
<br>
r2(A) w2(A) r2(B) w2(B) r1(A) w1(A) r1(B) w1(B)</p>
<p><strong>Konflikt – konfligieren</strong>
<img alt="title" src="../_images/def_konfligieren.jpg" /></p>
<section id="konfliktserialisierbarkeit-vs-serialisierbarkeit">
<h4><span class="section-number">11.4.1.1. </span>Konfliktserialisierbarkeit vs. Serialisierbarkeit<a class="headerlink" href="#konfliktserialisierbarkeit-vs-serialisierbarkeit" title="Permalink to this headline">#</a></h4>
<p>Wie oben genannt ist Konfliktserialisierbarkeit eine Bedingung für Serialisierbarkeit, demnach gilt Konfliktserialisierbarkeit =&gt; Serialisierbarkeit.
<br>
Betrachten wir nun den seriellen Schedule S1: w1(Y) w1(X) w2(Y) w2(X) w3(X). Der Schedule S2: w1(Y) w2(Y) w2(X) w1(X) w3(X) hat (zufällig) den gleichen Effekt wie S1 und ist also serialisierbar. Jedoch müssten konfligierende Aktionen getauscht werden, undzwar muss w1(X) vor w2(Y) getauscht werden, welches gegen die Konfliktserialisierbarkeit verstößt.
<br><br>
Was fällt auf? T3 überschreibt X sowieso, in dem Fall spricht man dann von Sichtserialisierbarkeit (nicht hier).</p>
</section>
</section>
<section id="graphbasierter-test">
<h3><span class="section-number">11.4.2. </span>Graphbasierter Test<a class="headerlink" href="#graphbasierter-test" title="Permalink to this headline">#</a></h3>
<p>Konfliktserialisierbarkeit kann auch graphbasiert, mittles eines Konfliktgraphen G(S) = (V,E) von Schedule S überprüft werden. Die Knotenmenge V enthält alle in S vorkommenden Transaktionen und die Kantenmenge E enthält alle gerichteten Kanten zwischen zwei konfligierenden Transaktionen. Die Kantenrichtung entspricht dem zeitlichem Ablauf im Schedule.
<br><br>
Nun gilt S ist ein konfliktserialisierbarer Schedule gdw. der vorliegende Konfliktgraph ein azyklischer Graph ist.
Für jeden azyklischen Graphen G(S) lässt sich ein serieller Schedule S‘ konstruieren, so dass S konfliktäquivalent zu S‘ ist, z.B mit topologischen Sortieren. Enthält der Konfliktgraph Zyklen, ist der zugehörige Schedule nicht konfliktserialisierbar.</p>
<p><br><br>
<strong>Beispiel 1</strong>
<br><br>
Wir haben folgenden Schedule gegeben und möchten graphbasiert überprüfen, ob dieser konfliktserialisierbar ist. Unsere Menge V ist V={T1,T3}. Nun schauen wir anhand den obigen Regeln wo Konflikte herrschen. Wir haben einen Konflikt von write(A)(Schritt 3) zu read(A)(Schritt 5) und demnach eine Kante von T1 zu T3. Weiterhin haben wir einen Konflikt von write(B)(Schritt 8) zu read(B)(Schritt 11) und demnach eine Kante von T3 zu T1. Da unser Konfliktgraph einen Zyklus enthält, ist unser Schedule nicht konfliktserialisierbar.</p>
<table>
    <tr><th>Schedule </th><th>Konfliktgraph</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>write(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>﻿</p></td>
<td><p>read(A)</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>write(A)</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>read(B)</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>write(B)</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>read(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>write(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<p><img alt="title" src="../_images/graph1.jpg" /></p>
</table>
<p><br><br>
<strong>Beispiel 2</strong>
<br><br>
Betrachten wir nun den Schedule S = r1(y) r3(u) r2(y) w1(y) w1(x) w2(x) w2(z) w3(x). Wir haben einen Konflikt von r2(y) zu w1(y), also hat unser Graph eine Kante von T2 zu T1. Dann gibt es weiterhin einen Konflikt von w1(x) zu w2(x), demnach hat unser Graph ein Kanten von  T1 zu T2. Nun hat unser Konfliktgraph schon eine Zyklus und wir wissen der Schedule S ist nicht konfliktserialisierbar.</p>
<table>
    <tr><th>Schedule </th><th>Konfliktgraph</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
<th class="head"><p>T3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>r(y)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>r(u)</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>﻿</p></td>
<td><p>r(y)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>w(y)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>w(x)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>w(x)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>﻿</p></td>
<td><p>w(z)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>w(x)</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<p><img alt="title" src="../_images/graph2.jpg" /></p>
</table>
<p><br><br>
<strong>Beispiel 3</strong>
<br><br>
In diesem Beispiel haben wir nur einen Konflikt von T1 nach T2 und können somit schließen, dass der Schedule konfliktserialisierbar ist. Der serielle Schedule lautet T3T1. Die Reihenfolge der Transaktionen, wird anhand der Pfeilrichtungen erkannt.</p>
<table>
    <tr><th>Schedule </th><th>Konfliktgraph</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Schritt</p></th>
<th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>BOT</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>read(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>3.</p></td>
<td><p>﻿</p></td>
<td><p>BOT</p></td>
</tr>
<tr class="row-odd"><td><p>4.</p></td>
<td><p>﻿</p></td>
<td><p>read©</p></td>
</tr>
<tr class="row-even"><td><p>5.</p></td>
<td><p>write(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>6.</p></td>
<td><p>﻿</p></td>
<td><p>write©</p></td>
</tr>
<tr class="row-even"><td><p>7.</p></td>
<td><p>read(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>8.</p></td>
<td><p>write(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>9.</p></td>
<td><p>commit</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>10.</p></td>
<td><p>﻿</p></td>
<td><p>read(A)</p></td>
</tr>
<tr class="row-even"><td><p>11.</p></td>
<td><p>﻿</p></td>
<td><p>write(A)</p></td>
</tr>
<tr class="row-odd"><td><p>12.</p></td>
<td><p>﻿</p></td>
<td><p>commit</p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<p><img alt="title" src="../_images/graph3.jpg" /></p>
</table>
<p>Beispie: Alfons Kemper(TU München)</p>
</section>
<section id="beweis">
<h3><span class="section-number">11.4.3. </span>Beweis<a class="headerlink" href="#beweis" title="Permalink to this headline">#</a></h3>
<p>Nun wollen wir folgendes beweisen: Konfliktgraph ist zykelfrei &lt;=&gt; Schedule ist konfliktserialisierbar
<br>
Wir zeigen zeurst die eine Richtung: Konfliktgraph ist zykelfrei &lt;= Schedule ist konfliktserialisierbar
<br>
Das ist leicht zu zeigen: Konfliktgraph hat Zykel =&gt; Schedule ist nicht konfliktserialisierbar, denn es ist nicht klar welche Transaktion zuerst ausgeführt werden soll, wie im untern Gegenbeispiel veranschaulicht.
<br>
Gegenbeispiel: T1 -&gt; T2 -&gt; … -&gt; Tn -&gt; T1
<br>
Jetzt zeigen wir die andere Richtung: Konfliktgraph ist zykelfrei =&gt; Schedule ist konfliktserialisierbar
<br>
Wir führen eine Induktion über die Anzahl n der Transaktionen durch.
<br>
n = 1: Graph und Schedule haben nur eine Transaktion. Es gibt keinen Zyklus.
<br>
n = n + 1:
<br>
Unser Graph ist zykelfrei
<br>
=&gt; ∃ mindestens ein Knoten Ti ohne eingehende Kante.
<br>
=&gt; ∄ Aktion einer anderen Transaktion, die vor einer Aktion in Ti ausgeführt wird und mit dieser Aktion in Konflikt steht.
<br>
Alle Aktionen aus Ti können an den Anfang bewegt werden (Reihenfolge innerhalb Ti bleibt erhalten).
<br>
D.h. der Restgraph ist wieder azyklisch (Entfernung von Kanten aus einem azyklischen Graph kann ihn nicht zyklisch machen).
<br>
Somit hat der Restgraph n-1 Transaktionen</p>
</section>
</section>
<section id="sperrkontrolle">
<h2><span class="section-number">11.5. </span>Sperrkontrolle<a class="headerlink" href="#sperrkontrolle" title="Permalink to this headline">#</a></h2>
<p>In diesem Kapitel beschäftigen wir uns wie mit Sperrkontrollen die  DBMS konfliktserialisierbare Schedules garantiert.</p>
<section id="scheduler">
<h3><span class="section-number">11.5.1. </span>Scheduler<a class="headerlink" href="#scheduler" title="Permalink to this headline">#</a></h3>
<p>Der Scheduler in einem DBMS garantiert konfliktserialisierbare (also auch serialisierbare) Schedules bei gleichzeitig laufenden Transaktionen. Wenn neue Transaktionen ausgeführt werden sollen, könnte der Scheduler jedesmal einen graphbasierten Test durchführen, jedoch ist dies sehr kostenaufwendig. Stattdessen wäre es einfacher Sperren und Sperrkontrollen zu benutzte, welches in fast allen DBMS realisiert ist. Die Idee dahinter ist, dass die Transaktion für die Dauer der Bearbeitung eines Datenbankobjekts dieses sperrt, s.d. andere Transaktionen nicht darauf zugreifen können.
<br></p>
<p><img alt="title" src="../_images/scheduler.jpg" /></p>
</section>
<section id="sperren">
<h3><span class="section-number">11.5.2. </span>Sperren<a class="headerlink" href="#sperren" title="Permalink to this headline">#</a></h3>
<p>Wie oben genannte ist die Idee, dass die Transaktionen zusätzlich zu den Aktionen auch Sperren anfordern und freigeben müssen. Bedingungen hierfür sind, dass die Transaktion konsistent ist. D.h., dass Lesen oder Schreiben eines Objektes nur nachdem die Sperre angefordert wurde und bevor die Sperre wieder freigegeben wurde, erlaubt ist.
Zusätzlich muss nachdem Sperren eines Objektes muss später dessen Freigabe erfolgen. Eine weitere Bedingung ist die Legalität des Schedules, welches meint, dass zwei Transaktionen nicht gleichzeitig das gleiche Objekt sperren dürfen. In diesem Kontext lernen wir zwei neue Aktionen kennen:
<br></p>
<ul class="simple">
<li><p>li(X): Transaktion i fordert Sperre für X an (lock).
<br></p></li>
<li><p>ui(X): Transaktion i gibt Sperre auf X frei (unlock).
<br><br></p></li>
<li><p>Konsistenz: Vor jedem ri(X) oder wi(X) kommt ein li(X) (mit keinem ui(X) dazwischen) und ein ui(X) danach.
<br></p></li>
<li><p>Legalität: Zwischen li(X) und lk(X) kommt immer ein ui(X)</p></li>
</ul>
</section>
<section id="schedules-mit-sperren">
<h3><span class="section-number">11.5.3. </span>Schedules mit Sperren<a class="headerlink" href="#schedules-mit-sperren" title="Permalink to this headline">#</a></h3>
<p>Folgende zwei Transaktionen sind gegeben:
<br></p>
<ul class="simple">
<li><p>r1(A)w1(A)r1(B)w1(B)
<br></p></li>
<li><p>r2(A)w2(A)r2(B)w2(B)</p></li>
</ul>
<p><br><br>
Wir wollen nun die Aktionen mit lock’s und unlock’s ergänzen:
<br><br></p>
<ul class="simple">
<li><p>l1(A)r1(A)w1(A)u1(A)l1(B)r1(B)w1(B)u1(B)
<br></p></li>
<li><p>l2(A)r2(A)w2(A)u2(a)l2(B)r2(b)w2(B)u2(B)
<br><br></p></li>
</ul>
<p>Der Schedule der beiden Transaktionen sieht wie folgt aus:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>l1(A)r1(A)w1(A)u1(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>l2(A)r2(A)w2(A)u2(A)</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>l2(B)r2(B)w2(B)u2(B)</p></td>
</tr>
<tr class="row-odd"><td><p>l1(B)r1(B)w1(B)u1(B)</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
<p>Wir fragen uns ob der Schedule legal ist? Ja der Schedule ist legal, denn zwischen allen li(X) und lk(X) kommt immer ein ui(X).
<br>
Konfliktserialisierbar? Der Schedule ist <strong>nicht</strong> konfliktserialisierbar, denn in unserem zugehörigen Konfliktgraph gibt es eine Kante von T1 zu T2 und von T2 zu T1.
<br><br>
Der folgende Schedule gleicht im Grunde dem obigen. Es wird lediglich zusätzlich noch dargestellt, was für Werte die lokalen Varialen haben. Genau wie der Schedule oben, ist dieser Schedule legal, jedoch nicht serialisierbar und auch nicht konfliktserialisierbar.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>25</p></td>
<td><p>25</p></td>
</tr>
<tr class="row-odd"><td><p>l(A); read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>a1 := a1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>125</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>write(A,a1); u(A)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>l(A); read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>a2 := a2 * 2</p></td>
<td><p>250</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>write(A,a2); u(A)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>l(B); read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>b2 := b2 * 2</p></td>
<td><p>﻿</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>write(B,b2); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>l(B); read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>b1 := b1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>150</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>write(B,b1); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="freigabe-durch-scheduler">
<h3><span class="section-number">11.5.4. </span>Freigabe durch Scheduler<a class="headerlink" href="#freigabe-durch-scheduler" title="Permalink to this headline">#</a></h3>
<p>Um das Problem aus dem vorherigen Kapitel zu lösen, ist dasnn alle Sperren vor den Entsperren ausgeführt werden.
<br>
<br>
Unsere alte Transaktionen:
<br>
– l1(A)r1(A)w1(A)u1(A)l1(B)r1(B)w1(B)u1(B)
<br>
– l2(A)r2(A)w2(A)u2(A)l2(B)r2(B)w2(B)u2(B)
<br><br>
In unseren neuen Transaktionen sind alle Sperren vor Entsperren:
<br>
– l1(A)r1(A)w1(A)l1(B)u1(A)r1(B)w1(B)u1(B)
<br>
– l2(A)r2(A)w2(A)l2(B)u2(A)r2(B)w2(B)u2(B)
<br>
<br>
Somit ist unser Schedule konsistent und legal.
<br><br>
Der Scheduler gibt Objektefrei und vergibt nur Sperren, wenn keine andere Sperre existiert. Die Sperrinformation werden von dem Scheduler in einer Sperrtabelle gespeichert.</p>
</section>
<section id="id1">
<h3><span class="section-number">11.5.5. </span>Schedules mit Sperren<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h3>
<p>Im Vergleich zu dem Schedule oben wird hier erst B von T1 gesperrt und dann A entsperrt. Danach wird A von T3 gesperrt und es wird auf A geschrieben. T3 fordert nun die Sperre von B an, das wird jedoch abgelehnt, da B noch von T1 gesperrt wird. Anschließend schreibt T1 auf B und gibt diese frei und zuletzt kann T3 auf B schreiben. Dieser Schedule ist legal, da alle Sperren von Entsperren stattfinden. Dieser Schedule ist ebenfalls serilialisierbar und konfliktserialisierbar, da der zueghörige Konfliktgraph azyklisch ist.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>25</p></td>
<td><p>25</p></td>
</tr>
<tr class="row-odd"><td><p>l(A); read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>a1 := a1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>125</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>write(A,a1); l(B); u(A)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>l(A); read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>a2 := a2 * 2</p></td>
<td><p>250</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>write(A,a2);</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>l(B); abgelehnt!</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>b1 := b1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>125</p></td>
</tr>
<tr class="row-even"><td><p>write(B,b1); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>l(B); u(A); read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>b2 := b2 * 2</p></td>
<td><p>﻿</p></td>
<td><p>250</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>write(B,b2); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</section>
<section id="phasen-sperrprotokoll">
<h3><span class="section-number">11.5.6. </span>2-Phasen Sperrprotokoll<a class="headerlink" href="#phasen-sperrprotokoll" title="Permalink to this headline">#</a></h3>
<p>2-Phase-Locking (2PL) ist eine einfache Bedingung an <strong>Transaktionen</strong>, nicht an den Schedule, die  Konfliktserialisierbarkeit garantiert. Es besteht aus zwei Phasen:</p>
<ul class="simple">
<li><p>Phase 1: Sperrphase
<br></p></li>
<li><p>Phase 2: Freigabephase
<br>
So geschen alle Sperranforderungen vor allen Sperrfreigaben.</p></li>
</ul>
<section id="phasen-sperrprotokoll-beispiel">
<h4><span class="section-number">11.5.6.1. </span>2-Phasen Sperrprotokoll – Beispiel<a class="headerlink" href="#phasen-sperrprotokoll-beispiel" title="Permalink to this headline">#</a></h4>
<table>
    <tr><th>Schedule ohne 2-Phasen Sperrprotokoll </th><th>Schedule mit 2-Phasen Sperrprotokoll</th></tr>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>25</p></td>
<td><p>25</p></td>
</tr>
<tr class="row-odd"><td><p>l(A); read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>a1 := a1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>125</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>write(A,a1); u(A)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>l(A); read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>a2 := a2 * 2</p></td>
<td><p>250</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>write(A,a2); u(A)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>l(B); read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>b2 := b2 * 2</p></td>
<td><p>﻿</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>write(B,b2); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>l(B); read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>b1 := b1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>150</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>write(B,b1); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</td>
    <td>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T3</p></th>
<th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>25</p></td>
<td><p>25</p></td>
</tr>
<tr class="row-odd"><td><p>l(A); read(A,a1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>a1 := a1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>125</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>write(A,a1); l(B); u(A)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>l(A); read(A,a2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>a2 := a2 * 2</p></td>
<td><p>250</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>write(A,a2);</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>l(B); abgelehnt!</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>read(B,b1)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>b1 := b1 + 100</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>125</p></td>
</tr>
<tr class="row-even"><td><p>write(B,b1); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>l(B); u(A); read(B,b2)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>b2 := b2 * 2</p></td>
<td><p>﻿</p></td>
<td><p>250</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>write(B,b2); u(B)</p></td>
<td><p>﻿</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</table>
</section>
<section id="deadlocks-unter-2pl-moglich">
<h4><span class="section-number">11.5.6.2. </span>Deadlocks unter 2PL möglich<a class="headerlink" href="#deadlocks-unter-2pl-moglich" title="Permalink to this headline">#</a></h4>
<p>Leider sind unter 2PL nicht alle Probleme gelöst, denn ein 2PL-konformer Schedule kann immernoch Deadlocks hervorrufen, wie im unteren Schedule zu sehen ist.
<br><br></p>
<ul class="simple">
<li><p>T1: l(A); r(A); A:=A+100; w(A); l(B); u(A); r(B); B:=B-100; w(B); u(B)
<br></p></li>
<li><p>T4: l(B); r(B); B:=B*2; w(B); l(A); u(B); r(A); A:=A*2; w(A); u(A)
<br><br>
Zunächst sperrt T1 A und schreibt auf A. Danach sperrt T4 B und schreibt auf B. Folgend möchte T1 auf B schreiben, dies wird abgelehnt, da T4 B gesperrt hat. T4 möchte nun auch A schreiben, jedoch ist A noch von T1 besetzt. Nun haben wir ein Deadlock, denn beide Transaktionen warten auf die Freigaben des anderen. Eine mögliche Lösung ist das Einsetzten von Timeouts oder es können  „Waits-for“-Graph benutzt werden.
|T1|T4|A|B|
|—|—|—|—|
|﻿|﻿|25|25|
|l(A); read(A,a1)|﻿|﻿|﻿|
|﻿|l(B); read(B,b2)|﻿|﻿|
|a1 := a1 + 100|﻿|﻿|﻿|
|﻿|b2 := b2 * 2|﻿|﻿|
|write(A,a1)|﻿|125|﻿|
|﻿|write(B,b2)|﻿|50|
|l(B) – abgelehnt|﻿|﻿|﻿|
|﻿|l(A) – abgelehnt|﻿|﻿|</p></li>
</ul>
</section>
<section id="pl-intuition">
<h4><span class="section-number">11.5.6.3. </span>2PL – Intuition<a class="headerlink" href="#pl-intuition" title="Permalink to this headline">#</a></h4>
<p>Die Intuition hinter 2Pl ist, dass in der Reihenfolge des äquivalenten seriellen Schedules, zuerst die Transaktion kommt, welche als Erstes Sperren freigibt. Jede Transaktion führt sämtliche Aktionen in dem Augenblick aus, zu dem das erste Objekt freigegeben wird.
<br>
<img alt="title" src="../_images/2pl_intuition.jpg" /></p>
</section>
<section id="pl-beweis">
<h4><span class="section-number">11.5.6.4. </span>2PL – Beweis<a class="headerlink" href="#pl-beweis" title="Permalink to this headline">#</a></h4>
<p>Nun wollen wir dies auch beweisen. Die Idee ist, dass wir einen beliebigen, legalen Schedule S aus konsistenten, 2PL Transaktionen in einen konfliktäquivalenten seriellen Schedule konvertieren.
<br><br>
Wir führen eine Induktion über die Anzahl der Transaktionen n durch.
<br><br></p>
<ul class="simple">
<li><p>n = 1: Schedule S ist bereits seriell
<br><br></p></li>
<li><p>n = n + 1:
Enthalte S die Transaktionen T1, T2, …, Tn.
<br><br>
Sei Ti die Transaktion mit der ersten Freigabe ui(X).
<br><br>
Wir behaupten: Es ist möglich, alle Aktionen der Transaktion an den Anfang des Schedules zu bewegen, ohne konfligierende Aktionen zu passieren.
<br><br>
Nun nehmen wir an, dass es eine Schreibaktion wi(Y) gibt, die man nicht verschieben kann:
<br><br>
– … wk(Y) … uk(Y) … li(Y) … wi(Y) …
<br><br>
Da Ti die erste freigebenden Transaktion ist, gibt es ein ui(X) vor uk(Y):
<br><br>
– … wk(Y) … ui(X) … uk(Y) … li(Y) … wi(Y) …
<br><br>
Dasselbe gilt analog für eine Leseaktion ri(Y).
<br><br>
Somit ist Ti nicht 2PL.</p></li>
</ul>
</section>
</section>
<section id="mehrere-sperrmodi">
<h3><span class="section-number">11.5.7. </span>Mehrere Sperrmodi<a class="headerlink" href="#mehrere-sperrmodi" title="Permalink to this headline">#</a></h3>
<p>Die Idee hinter mehreren Arten von Sperren ist, dass so die Flexibilität erhöht wird und die Menge der abgewiesenen Sperren verringert wird.
<br>
Z.B sind Sperren obwohl nur gelesen wird übertrieben.Eine gewisse Sperre ist dennoch nötig, aber mehrere Transaktionen sollen auch gleichzeitig lesen können. Für Leseoperationen können sogenannte shared locks si(X) angefordert werden. Diese erlaubt dann das Lesen für die Transaktion Ti und sperrt zudem auch den Schreibzugriff für alle anderen Transaktionen. Für Schreiboperationen wir eine exclusive lock xli(X) angefordert, welches das Lesen und Schreiben durch Transaktion Ti erlaubt. Um diese beiden Sperren aufzuheben wird wie schon bekannt einfach ein unlock ui(X) angefordert. Was die Kompabilität angeht, darf es für ein Objekt nur eine Schreibsperre oder mehrere Lesesperren geben.</p>
</section>
<section id="bedingungen">
<h3><span class="section-number">11.5.8. </span>Bedingungen<a class="headerlink" href="#bedingungen" title="Permalink to this headline">#</a></h3>
<p>Um die Konsistenz von Transaktionen zu wahren ist Schreiben ohne Schreibsperre und Lesen ohne irgendeine Sperre nicht erlaubt. Ebenso muss jede Sperre irgendwann freigegeben werden.
<br><br>
Mit den Speermodi hat sich bei der 2PL-Konformität von Transaktionen nichts geändert. Wie zuvor auch dürfen nach der ersten Freigabe keine Sperren mehr angefordert werden.
<br><br>
Was die Legalität von Schedules betrifft, darf es auf ein Objekt mit einer Schreibsperre keine andere Sperre einer anderen Transaktion geben und auf ein Objekt kann es mehrere Lesesperren geben. Die untere Tabelle stellt nocheinmal die Kompabilität der verschiedenen Sperren dar.
<br>
<img alt="title" src="../_images/bedingungen.jpg" /></p>
<p><strong>Beispiel</strong>
<br><br>
T1 sperrt zunächst A mit einem sharedlock, T2 tut dem ebenso und sperrt zusätzlich noch B. Folgend fordert T1 ein exclusive lock an B, jedoch ist B mit einem shared lock von T2 besetzt, weshalb die Anfrage abgelehnt wird. T2 gibt A und B frei. Zuletzt wird von T1 erneut ein exclusive lock an B angefordert und T1 liest und schreibt auf B. Ganz zum Schluss werden die Sperren von T1 freigegeben.
<br><br></p>
<ul class="simple">
<li><p>T1: sl1(A)r1(A)xl1(B)r1(B)w1(B)u1(A)u1(B)
<br></p></li>
<li><p>T2: sl2(A)r2(A)sl2(B)r2(B)u2(A)u2(B)
<br></p></li>
<li><p>Konsistent? Ja der Beispielschedule ist konsistent
<br></p></li>
<li><p>2PL? Ja der Beispielschedule ist 2PL-konform</p></li>
</ul>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>T1</p></th>
<th class="head"><p>T2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sl(A); r(A)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-odd"><td><p>﻿</p></td>
<td><p>sl(A)r(A)</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>sl(B)r(B)</p></td>
</tr>
<tr class="row-odd"><td><p>xl(B) – abgelehnt!</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>﻿</p></td>
<td><p>u(A)u(B)</p></td>
</tr>
<tr class="row-odd"><td><p>xl(B)r(B)w(B)</p></td>
<td><p>﻿</p></td>
</tr>
<tr class="row-even"><td><p>u(A)u(B)</p></td>
<td><p>﻿</p></td>
</tr>
</tbody>
</table>
</section>
<section id="weitere-sperrarten">
<h3><span class="section-number">11.5.9. </span>Weitere Sperrarten<a class="headerlink" href="#weitere-sperrarten" title="Permalink to this headline">#</a></h3>
<p>Eine weitere Sperrart ist Upgraden einer Sperre von einer Lesesperre zu einer Schreibsperre, anstatt gleich strenge Schreibsperre zu setzen. Es ist auch möglich Updatesperren zu setzten, diese erlaubt nur lesenden Zugriff, jedoch kann ein Upgrade erfahren. Die klassische Lesesperre kann dann keinen Upgrade erfahren. Eine Inkrementsperre erlaubt lesenden Zugriff und erlaubt schreibenden Zugriff, falls der Wert nur inkrementiert (oder dekrementiert) wird. Dies ist erlaubt da Inkremente kommutativ sind, also sind Vertauschung erlaubt.</p>
</section>
</section>
<section id="fragen">
<h2><span class="section-number">11.6. </span>Fragen<a class="headerlink" href="#fragen" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Die hier verwendete Version des Multiple-Choice-Trainers von EILD.nrw wird über GitHub-Pages gehostet und in das Skript eingebunden.</p></li>
<li><p>Alle Fragen und Kategorien befinden sich zurzeit in Überarbeitung und sind nicht final.</p></li>
<li><p><strong>Für den vollen Funktionsumfang wird empfohlen einen auf Firefox basierten Browser zu nutzen, ansonsten können  unerwünschte Nebeneffekte entstehen.</strong></p></li>
</ul>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="100%"
            height="800"
            src="https://luh-dbs.github.io/mct-trainer/#/quiz/categories/transaktionsmanagement"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./11"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../10/integritaet_und_trigger.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">10. </span>Integrität und Trigger</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../12/bearbeitung.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">12. </span>Bearbeitung</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Prof. Dr. Ziawasch Abedjan<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>